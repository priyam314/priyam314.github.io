[{"content":" Ever felt why we even need Variational AutoEncoders when simple AutoEncoders worked greatly?\nAnd what the heck is this Variational Inference anyway?\nLeave why or what, whats\u0026rsquo; going on with its\u0026rsquo; mathematics, too hard to grab any intutive understanding!!\nI dealt with these problems for long, and maybe others\u0026rsquo; did too.\nDont\u0026rsquo; worry, Variational Inference: The Path üõ£Ô∏è Forward is here for rescue.\nI have tried to keep things as streamlined as possible, such that readers don\u0026rsquo;t have to worry about connecting broken links among concepts.\nDo give it a read, I hope it will provide some clarity over confusions.\nThankyou, Eulogs\n","permalink":"https://www.eulogs.com/newsletter/001-vi/","summary":"Ever felt why we even need Variational AutoEncoders when simple AutoEncoders worked greatly?\nAnd what the heck is this Variational Inference anyway?\nLeave why or what, whats\u0026rsquo; going on with its\u0026rsquo; mathematics, too hard to grab any intutive understanding!!\nI dealt with these problems for long, and maybe others\u0026rsquo; did too.\nDont\u0026rsquo; worry, Variational Inference: The Path üõ£Ô∏è Forward is here for rescue.\nI have tried to keep things as streamlined as possible, such that readers don\u0026rsquo;t have to worry about connecting broken links among concepts.","title":"Variational Inference: The Path Forward"},{"content":" üö® Heavy Math Ahead The following article features maths on steroids, which could delay your page load time. Recommended to refresh once. We apologize for the inconvenience. Science does not aim at establishing immutable truths and eternal dogmas; its aim is to approach the truth by successive approximations, without claiming that at any stage final and complete accuracy has been achieved.\n\u0026ndash;Bertrand Russell\nMotivation Lets\u0026rsquo; recall the Bayes theorem that most of us might already be familiar with, it goes like $P(A \\vert B) = \\displaystyle \\frac{P(B \\vert A)P(A)}{P(B)}$. Here, $P(B \\vert A)$ is conditional probability which can be interpreted as likelihood function or probability density function if working with continuous system else probability mass function. $P(A)$ is prior probability which is assumed probability distribution of the system before any evidence is taken in account. $P(B)$ is marginal probability which is used as a normalizing quantity. All the recently mentioned quantities are used to inference(reaching conclusion on the basis of evidence and reasoning) about posterior $P(A \\vert B)$.\nIn bayesian models, we use latent(hidden) variables which govern the distribution of data. We can write these latent variables as $z$ and data (say for images) as $x$. Now bayes theorem will become $P(z \\vert x) = \\displaystyle \\frac{P(x \\vert z)P(z)}{P(x)}$, in words it would mean that we have currently assumed some prior distribution over latent variables(e.g. standard normal) multiplying it with likelihood function of getting desired image $x$ for fixed latent variable $z$ and normalizing it with marginal probability of finding desired image out of all plausibilities as $P(x)$. We know prior distribution because we are assuming it, so we may sample from it too and this would make likelihood function to be tractable too since we know $x$, $z$. But quantity that brings hinderance to solving posterior is marginal probability, since we have no realization that how many possible values of $x$ may exist such that we cannot find the probability of getting desired image $x$ out of all plausibilities.\nSo, we need to talk about the problem of marginal probability distribution here, lets\u0026rsquo; expand the formulation in terms of joint probability.\n$$ \\begin{align} P(x) = \\int_{z} P(x, z) \\ dz \\label{eq:1}\\tag{1} \\end{align} $$\nEquation (\\ref{eq:1}) says that marginal probability is equal to integration of joint probability over all the values of $z$, though we have prior on $z$ but its\u0026rsquo; an assumption and so it may happen that we dont\u0026rsquo; get all the values for $z$, and in that case our integral will not be in closed form which in turn will not give exact value of integral and we would need to approximate. One of the core problems of modern statistics is to approximate difficult-to-compute probability densities.\nIntroduction There are various methods for solving approximation problems, one of them is variational inference (VI), which is widely used to approximate posterior densities for Bayesian models. But theres\u0026rsquo; an alternative to that, Markov Chain Monte Carlo (MCMC) sampling. We will talk briefly about MCMC and see why these methods are not optimal to work with for most machine learning tasks.\nMarkov Chain Monte Carlo MCMC approaches have grown in popularity during the past few decades. These are computer-driven sampling approaches that allow one to describe the nature of a distribution without understanding its mathematical properties by randomly sampling out the data.\nThe word MCMC is a combination of two properties: Monte-Carlo and Markov chain. Monte Carlo is the practise of estimating the parameters of a distribution by studying random samples from the distribution. For example, instead of simply computing the mean of a normal distribution from its equations, a Monte Carlo technique would be to pick a large number of random samples from a normal distribution and compute the sample mean of them. This advantage is most noticeable when drawing random samples is simple, and distributions\u0026rsquo; equations are hard to work with.\nThe notion behind MCMC\u0026rsquo;s Markov chain property is that random samples are generated via a particular sequential process. Each random sample serves as a stepping stone for the generation of the next random sample (thus the chain). The chain has a unique characteristic in that, while each new sample depends on the one before it, new samples do not depend on any samples before the prior one (this is known as the \u0026ldquo;Markov\u0026rdquo; property) [2].\nIn MCMC, we first construct an ergodic Markov chain on $z$ whose stationary distribution is the posterior $P(z | x)$. Then, we sample from the chain to collect samples from the stationary distribution. Finally, we approximate the posterior with an empirical estimate constructed from (a subset of) the collected samples [1].\nBenefits Indispensible tool to modern bayesian statstics Landmark developments like:- Metopolis-Hastings Algorithm Gibbs Sampler Hamilton Monte Carlo Provide guarantees of producing asymptotically exact samples from target density. MCMC have been widely studied, extended and applied to more than field of statistics but even to psychology.\nLimitations But, alas, every rose has its\u0026rsquo; thorn.\nSampling speed slows down as size of datasets or complexity of models increases. Computationally more intensive than Variational Inference For mixture models, MCMC sampling approach of Gibbs Sampling is not an option even for small datasets This is why, MCMC is suited to smaller datasets and scenerios where we pay heavy computational cost for more precise samples.\nVariational Inference The key idea behind the variational inference is to approximate a conditional density or posterior of latent variables given observed variables $P(\\textbf{z} \\vert \\boldsymbol{x})$. Its\u0026rsquo; important to note that we dont\u0026rsquo; approximate with single datapoint or sample but with arbitrarily many. So $\\boldsymbol{x} = x_{1:n}$ be set of $n$ observed variables and $\\textbf{z} = z_{1:m}$ be a set of $m$ latent variables. In the motivation section we have already set the stage for describing the problem with Bayesian theorem.\nBayesian Mixture of Gaussians Consider a mixture of univariate Gaussians having unit-variance $(\\sigma^{2} = 1)$ and $K$ mixture components.\nMeans $\\boldsymbol{\\mu} = \\lbrace \\mu_{1},\u0026hellip;,\\mu_{K} \\rbrace$ for \\(K\\) Gaussian distributions. These mean values are sampled independently from common prior density $P(\\mu_{k})$, which is assumed to be Gaussian $\\mathcal{N}(0, \\sigma^{2})$ where $\\sigma^{2}$ is hyperparameter.\nTo generate an observation $x_{i}$ from the model, we first need to choose cluster assignment $c_{i}$, which is an indicator function that indicates from which cluster $x_{i}$ comes. It is sampled from categorical distribution over $ \\lbrace 1,\u0026hellip;,K \\rbrace $ since we have $K$ clusters. So its\u0026rsquo; $\\displaystyle \\frac{1}{K}$ probability for $c_{i}$ to choose any cluster. Every $x_{i}$ will have corresponding $c_{i}$, and $c_{i}$ will itself be $K$ dimensional. For e.g. $c_{i} = [ 0,0,0,1,0,0 ]$, this indicates that $x_{i}$ belongs to $4^{th}$ cluster out of $K=6$ clusters.\nEvery cluster will be of following probability density; $\\mathcal{N}(c_{i}^{T}\\boldsymbol{\\mu}, 1)$.\nUnivariate Mixture of GaussiansIn this visualization red color of gaussian distribution is prior density with œÉ=4 and ¬µ=0. Three random values are sampled from prior as means of other three distribution in color green, yellow and blue with œÉ=1. Vertical line shows the mean of each distribution.\nFull hierarchical model is, $$ \\begin{align} \\mu_{k} \u0026amp;\\sim \\mathcal{N}(0, \\sigma^{2}) \u0026amp; k \u0026amp;= 1,\u0026hellip;,K \\label{eq:2}\\tag{2} \\cr c_{i} \u0026amp;\\sim Categorical(\\frac{1}{K},\u0026hellip;,\\frac{1}{K}) \u0026amp; i \u0026amp;= 1,\u0026hellip;,n \\tag{3} \\cr x_{i} \\vert c_{i}, \\boldsymbol{\\mu} \u0026amp;\\sim \\mathcal{N}(c_{i}^{T}\\boldsymbol{\\mu}, 1) \u0026amp; i \u0026amp;= 1,\u0026hellip;,n \\label{eq:4}\\tag{4} \\end{align} $$\n$c_i$ is independent of $c_j$ where $i \\ne j$ and this makes $x_i$ only dependent on $c_i$, so joint density of latent and observed variables for $n$ data samples will be,\n$$ \\begin{align} P(\\boldsymbol{z, x}) \u0026amp;= P(\\boldsymbol{\\mu, c, x}) \u0026amp; \\cr \u0026amp;= P(\\boldsymbol{x}\\vert\\boldsymbol{c,\\mu})P(\\boldsymbol{c}\\vert\\boldsymbol{\\mu})P(\\boldsymbol{\\mu}) \\cr \u0026amp;= P(\\boldsymbol{x}\\vert\\boldsymbol{c,\\mu})P(\\boldsymbol{c})P(\\boldsymbol{\\mu}) \\tag{5} \\cr P(\\boldsymbol{\\mu}, c_{1},\u0026hellip;,c_{n},x_{1},\u0026hellip;,x_{n}) \u0026amp;= P(\\boldsymbol{\\mu})P(x_{1},\u0026hellip;,x_{n}\\vert c_{1}, \u0026hellip;, c_{n}, \\boldsymbol{\\mu}) \\cr \u0026amp; \\qquad P(c_{1},\u0026hellip;,c_{n}) \\cr \u0026amp;= P(\\boldsymbol{\\mu})\\prod_{i=1}^{n}P(c_{i})P(x_{i}\\vert c_{i}, \\boldsymbol{\\mu}) \\label{eq:6}\\tag{6} \\end{align} $$\nNote that $\\boldsymbol{\\mu}$ though independent, has not been decomposed to independent $\\mu_k$ like $\\boldsymbol{c}$, since $x_i$ can be sampled from any of $K$ clusters. This is why we cannot decompose the $\\boldsymbol{\\mu}$. We took latent variables $\\boldsymbol{z}={\\boldsymbol{\\mu},\\boldsymbol{c}}$. Now evidence is,\n$$ \\begin{align} P(\\boldsymbol{x}) \u0026amp;= \\int_{\\boldsymbol{\\mu}}\\int_{\\boldsymbol{c}}P(\\boldsymbol{\\mu})\\prod_{i=1}^{n}P(c_{i})P(x_{i} \\vert c_{i}, \\boldsymbol{\\mu}) \\ d\\boldsymbol{c} \\ d\\boldsymbol{\\mu} \\cr \u0026amp;= \\int_{\\boldsymbol{\\mu}} \\sum_{j=1}^{n}P(\\boldsymbol{\\mu})\\prod_{i=1}^{n} P(c_{j})P(x_{i}\\vert c_{j}, \\boldsymbol{\\mu}) \\ d\\boldsymbol{\\mu} \\cr \u0026amp;= \\int_{\\boldsymbol{\\mu}} P(\\boldsymbol{\\mu}) \\prod_{i=1}^{n} \\sum_{j=1}^{n} P(c_{j})P(x_{i} \\vert c_{j}, \\boldsymbol{\\mu}) \\ d\\boldsymbol{\\mu} \\tag{7} \\end{align} $$\nTime complexity of numerically evaluating the $K$-dimensional integral(since $\\boldsymbol{\\mu}$ is $K$-dimensional) is $O(K^{n})$. Its\u0026rsquo; interesting to note that $\\sum$ term will be vectorized and will take one unit computing time, and only $\\prod$ term will be left with $n$ as max samples.\nSo computing the evidence remains exponential in $K$, hence intractable.\nEvidence Lower Bound Recall, that we are facing hardships in evaluating the posterior $P(\\boldsymbol{z} \\vert \\boldsymbol{x})$. Now, the main idea behind variational inference is to approximate this posterior by optimizing the parameters of some family of density function e.g. Gaussian such that it will minimize the KL-Divergence between these two distributions.\n$$ \\begin{align} q^{*}(\\boldsymbol{z}) = \\arg \\min_{q(\\boldsymbol{z}) \\in \\mathcal{D}} KL(q(\\boldsymbol{z}) \\Vert P(\\boldsymbol{z} \\vert \\boldsymbol{x})) \\tag{8} \\end{align} $$\nwhere, $\\mathcal{D}$ is a family of densities over latent variables, e.g. Gaussian, Bernoulli, Gamma probability density functions. By $q(\\boldsymbol{z}) \\in \\mathcal{D}$ we are going to choose one family, but every family will have infinite members e.g. Gaussian has hyper-parameters $\\mu, \\sigma^{2}$ mean, variance respectively and each pair of values of both hyperparameters will result in a different member.\nOur goal is to find that best candidate(member from choosen family) that reduces the value of KL-Divergence the most. Its\u0026rsquo; important to note that the complexity of the family determines the complexity of this optimization.\n$$ \\begin{align} KL(q(\\boldsymbol{z}) \\Vert P(\\boldsymbol{z} \\vert \\boldsymbol{x})) \u0026amp;= \\mathbb{E_{z \\sim q(\\boldsymbol{z})}} \\left [\\log \\frac{q(\\boldsymbol{z})}{P(\\boldsymbol{z} \\vert \\boldsymbol{x})}\\right ] \\cr \u0026amp;= \\mathbb{E_{z \\sim q(\\boldsymbol{z})}} [\\log q(\\boldsymbol{z})] - \\mathbb{E_{z \\sim q(\\boldsymbol{z})}} [\\log P(\\boldsymbol{z} \\vert \\boldsymbol{x})] \\cr \u0026amp;= \\mathbb{E_{z \\sim q(\\boldsymbol{z})}} [\\log q(\\boldsymbol{z})] - \\mathbb{E_{z \\sim q(\\boldsymbol{z})}} [\\log P(\\boldsymbol{z}, \\boldsymbol{x})] \\cr \u0026amp; \\qquad + \\ \\mathbb{E_{z \\sim q(\\boldsymbol{z})}} [\\log P(\\boldsymbol{x})] \\cr \u0026amp;= \\underbrace{\\mathbb{E_{z \\sim q(\\boldsymbol{z})}} [\\log q(\\boldsymbol{z})] - \\mathbb{E_{z \\sim q(\\boldsymbol{z})}} [\\log P(\\boldsymbol{z}, \\boldsymbol{x})]}_{\\text{-ELBO(q)}} \\cr \u0026amp; \\qquad + \\ log P(\\boldsymbol{x}) \\label{eq:9}\\tag{9} \\cr \\end{align} $$\nAbove equation has dependence on $\\log P(\\boldsymbol{x})$, and since we cannot evaluate this marginal probability of $P(\\boldsymbol{x})$, we cannot compute KL-Divergence. But, this marginal log probability term will actually work as constant in optimization, since optimization is with respect to $q(\\boldsymbol{z})$.\nSo we optimize an alternative objective called ELBO(evidence lower bound).\n$$ \\begin{align} ELBO(q) = \\mathbb{E_{z \\sim q(\\boldsymbol{z})}} [\\log P(\\boldsymbol{z}, \\boldsymbol{x})] - \\mathbb{E_{z \\sim q(\\boldsymbol{z})}} [\\log q(\\boldsymbol{z})] \\label{eq:10}\\tag{10} \\end{align} $$\nELBO is negative KL-Divergence plus constant $(\\log P(\\boldsymbol{x})$). So maximizing the ELBO is equivalent to minimizing the KL-Divergence.\n$$ \\begin{align} ELBO(q) \u0026amp;= \\mathbb{E_{z \\sim q(\\boldsymbol{z})}}[\\log P(\\boldsymbol{z})P(\\boldsymbol{x} \\vert \\boldsymbol{z})] - \\mathbb{E_{z \\sim q(\\boldsymbol{z})}}[\\log q(\\boldsymbol{z})] \\cr \u0026amp;= \\mathbb{E_{z \\sim q(\\boldsymbol{z})}} [\\log P(\\boldsymbol{z})] + \\mathbb{E_{z \\sim q(\\boldsymbol{z})}}[\\log P(\\boldsymbol{x} \\vert \\boldsymbol{z})] \\cr \u0026amp; \\qquad - \\ \\mathbb{E_{z \\sim q(\\boldsymbol{z})}} [\\log q(\\boldsymbol{z})] \\cr \u0026amp;= \\mathbb{E_{z \\sim q(\\boldsymbol{z})}} [\\log P(\\boldsymbol{x} \\vert \\boldsymbol{z})] - \\mathbb{E_{z \\sim q(\\boldsymbol{z})}}\\left [\\log \\frac{q(\\boldsymbol{z})}{P(\\boldsymbol{z})} \\right ] \\cr \u0026amp;= \\mathbb{E_{z \\sim q(\\boldsymbol{z})}} [\\log P(\\boldsymbol{x} \\vert \\boldsymbol{z})] - KL(q(\\boldsymbol{z}) \\Vert P(\\boldsymbol{z})) \\tag{11} \\cr \\end{align} $$\nOur variational objective is to maximize the ELBO which in turn will decrease the KL-Divergence. For that, we would need to maximize the first term and minimize the second. This means that we need to increase the expected log likelihood of finding $\\boldsymbol{x}$ for given $\\boldsymbol{z}$ out of all the possible values of $\\boldsymbol{z}$, and minimize the KL-Divergence between variational density and prior beliefs, such that we stick close to our prior beliefs and at the same time obtain accurate posterior distribution.\nUsing equation $(\\ref{eq:9})$, we get\n$$ \\begin{align} \\log P(\\boldsymbol{x}) = ELBO(q) + KL(q(\\boldsymbol{z}) \\Vert P(\\boldsymbol{z} \\vert \\boldsymbol{x})) \\tag{12} \\end{align} $$\nWe know that $KL(\\cdot) \\ge 0$, then $\\log P(\\boldsymbol{x}) \\ge ELBO(q)$ for any $q(\\boldsymbol{z})$. This explains the name Evidence Lower Bound. And this is another property of ELBO. Variational free energy is another name we have for ELBO.\nEvidence Lower BoundELBO is lower bound on the log-likelihood. As a result, Œ∏-hat maximizing the ELBO does not necessarily coincide with Œ∏* that maximizing ln p(x). The looser the ELBO is, the more this can bias maximum likelihood estimates of the model parameters.\nThe relationship between the ELBO and $\\log P(\\boldsymbol{x})$ has led to using variational bound as a model selection criterion. The premise is that the bound is a good approximation of the marginal likelihood, which provides a basis for selecting a model.\nThe mean-field variational family Currently we have talked about ELBO in detail, to recall, ELBO transforms inference problems, which are intractable, into optimization problem by approximating a variational density function $q(\\boldsymbol{z})$ to posterior distribution $P(\\boldsymbol{z} \\vert \\boldsymbol{x})$. Now its\u0026rsquo; interesting to note that posterior may be complex distribution with more than one mode (multimodal), and in that case choosing for e.g. unimodal distriution from variational family may not help to approximate the posterior. And this becomes a problem that is prevalent with real world data.\nAs a solution we can have some members of variational family all trying collectively to fit closely to the posterior. Every member will be governed by distinct factors e.g. Gaussian distribution but with different mean and variances. But this is not going to be tractable due to multitude of dependency, so we assume latent variables to be independent. This is mean-field variational family.\nA generic member of mean-field variational family is\n$$ \\begin{align} q(\\boldsymbol{z}) = q(z_1, \u0026hellip; , z_m) = q_{\\phi_1}(z_1) \\cdot q_{\\phi_2}(z_2)\u0026hellip;q_{\\phi_m}(z_m) = \\prod_{j=1}^{m} q_{\\phi_{j}}(z_{j}) \\label{eq:13}\\tag{13} \\end{align} $$\n$q_{\\phi_j}(z_j)$ is a member of some variational family, and in optimization these variational factors $q_{\\phi_j}$ are choosen in such a manner to maximize the ELBO. These variational factors can be parameters of the distribution.\n‚ùóImportant Variational family is not a model of the observed data‚Äîindeed, the data x does not appear in the equation. Instead, it is the ELBO, and the corresponding KL minimization problem, that connects the fitted variational density to the data and model. Now lets apply a recently learned concept to bayesian mixture of Gaussians just like we did it earlier.\nBayesian mixture of Gaussians Conider again the bayesian mixture of Gaussians.\n$$ \\begin{align} q(\\boldsymbol{z}) \u0026amp;= q(\\boldsymbol{\\mu}, \\boldsymbol{c}) \\cr \u0026amp;= q(\\boldsymbol{\\mu} \\vert \\boldsymbol{c})q(\\boldsymbol{c}) \\cr \u0026amp;= q(\\boldsymbol{\\mu})q(\\boldsymbol{c}) \\cr \u0026amp;= q(\\mu_1, \u0026hellip;, \\mu_K) q(c_1, \u0026hellip;, c_n) \\cr \u0026amp;= \\prod_{k=1}^{K} q(\\mu_k) \\prod_{i=1}^{n} q(c_i) \\label{eq:14}\\tag{14}\\cr \u0026amp;= \\prod_{k=1}^{K}q_{\\phi_k}(\\mu_k;m_k, s_{k}^{2})\\prod_{i=1}^{n}q(c_i;\\psi_i) \\label{eq:15}\\tag{15}\\cr \\end{align} $$\nWe have to perform optimisation over these variational factors in order to update their values so that they will be able to come close to the posterior distribution. $\\mu_k$ is mean value we sampled from equation ($\\ref{eq:2}$), and after updating the variational factors this will become $m_k$, same goes for $c_i$, $\\psi_i$.\n$q_{\\phi_k}(\\mu_k;m_k, s_{k}^{2})$ is a Gaussian distribution on the $k^{th}$ mixture components\u0026rsquo; mean parameter; its\u0026rsquo; mean $m_k$ and its\u0026rsquo; variance is $s_{k}^{2}$. The factor $q(c_i;\\psi_i)$ is a distribution on the $i^{th}$ observations\u0026rsquo; mixture assignment which gives the probability of sampling $x_i$ from all the clusters in vector.\nMean-field family is expressive because it can capture any marginal density of the latent variables [1]. But every latent variable being independent loses the power of accounting correlations between them, making all the entries in the covariance matrix zero except the main diagonal. Such that, mean field doesn\u0026rsquo;t have only pros but cons too.\nMean-Field ApproximationVisualization of mean-field approximation to a two-dimensional Gaussian posterior.\nIn the above figure, it is mean-field variational density after mazimizing the ELBO. This mean-field approximation has same mean as the original posterior density but the covariance structure is decoupled. KL-Divergence penalizes placing probability mass in $q(\\cdot)$ on areas where $p(\\cdot)$ has more mass, but less than it penalizes placing probability mass in $q(\\cdot)$ on areas where $p(\\cdot)$ has little mass. And that it has done in above figure, but in order to have successful match of densities, $q(\\cdot)$ would have to expand into territory where $p(\\cdot)$ has little mass.\nCoordinate ascent mean-field variational inference Till now we have talked about intractability of Bayesian mixture of Gaussians and to solve this we introduced ELBO, but just introducing ELBO wont\u0026rsquo; help us since posterior distribution may be multimodal and to aid this approximation using our variational density we introduced mean-field variational family. But, our goal is still to maximize ELBO, and these stated concepts will help in that.\nCoordinate ascent mean-field variational inference (CAVI) is commonly used algorithms for solving this optimization problem. CAVI iteratively optimizes each factor ($q_{\\phi_i}$) of mean-field variational density, while holding others fixed(because of independency of latent variables). It climbs the ELBO to local optimum.\nUsing equation ($\\ref{eq:10}$), we know $ ELBO(q(\\boldsymbol{z})) = \\mathbb{E_{z \\sim q(\\boldsymbol{z})}} \\left [ \\log \\displaystyle \\frac{P(\\boldsymbol{x}, \\boldsymbol{z})}{q(\\boldsymbol{z})} \\right ]$.\n$$ \\begin{align} \\newcommand{\\E}{\\mathbb E} \\E_{\\boldsymbol{z} \\ \\sim \\ q(\\boldsymbol{z})}[\\log q(\\boldsymbol{z})] \u0026amp;= \\E_{\\boldsymbol{z} \\ \\sim \\ q(\\boldsymbol{z})}\\Big[\\sum_{j=1}^m \\log q_{\\phi_j}(z_j)\\Big] \\cr \u0026amp;= \\sum_{j=1}^m \\E_{z_j \\ \\sim \\ q(z_j)}[\\log q_{\\phi_j}(z_j)] \\cr \u0026amp;= \\quad \\E_{z_i \\ \\sim \\ q_{\\phi_i}(z_i)}[\\log q_{\\phi_i}(z_i)] \\cr \u0026amp; \\quad + \\sum_{k \\vert k \\ne i} \\E_{z_k \\ \\sim \\ q_{\\phi_k}(z_k)}[\\log q_{\\phi_k}(z_k)] \\cr \u0026amp;= \\quad \\E_{z_i \\ \\sim \\ q_{\\phi_i}(z_i)}[\\log q_{\\phi_i}(z_i)] \\cr \u0026amp; \\quad + \\ \\ \\overbrace{\\E_{z_{-i} \\ \\sim \\ q_{\\phi_{-i}(z_{-i})}}[\\log q_{\\phi_{-i}(z_{-i})}]}^{ z_{-i} \\text{ is fixed}} \\cr \u0026amp;= \\E_{z_i \\ \\sim \\ q_{\\phi_i}(z_i)}[\\log q_{\\phi_i}(z_i)] + \\text{ const} \\label{eq:16}\\tag{16} \\end{align} $$\n$$ \\begin{align} \\newcommand{\\E}{\\mathbb E} \\E_{\\boldsymbol{z} \\ \\sim \\ q(\\boldsymbol{z})}[\\log P(\\boldsymbol{x, z})] \u0026amp;= \\oint_{\\boldsymbol{z}} q(\\boldsymbol{z})\\log P(\\boldsymbol{x,z}) \\ d\\boldsymbol{z} \\cr \u0026amp;= \\int_{z_1}\\dotsi\\int_{z_m}\\prod_{j=1}^mq_{\\phi_j}(z_j)\\log P( \\boldsymbol{x, z}) \\ dz_1 \u0026hellip; \\ dz_m \\cr \u0026amp;= \\int_{z_j}q_{\\phi_j}(z_j)\\int_{z_1}\\dotsi\\int_{z_{j-1}}\\int_{z_{j+1}}\\dotsi\\int_{z_m} \\prod_{k \\vert k \\ne j}q_{\\phi_k}(z_k) \\cr \u0026amp; \\qquad \\log P(\\boldsymbol{x, z}) \\ dz_1\u0026hellip;dz_m \\cr \u0026amp;= \\int_{z_j}q_{\\phi_j}(z_j)\\Big[\\oint_{z_{-j}}q(z_{-j})\\log P(\\boldsymbol{x, z})\\ dz_{-j}\\Big] \\ dz_j \\cr \u0026amp;= \\int_{z_j} q_{\\phi_j}(z_j)\\E_{z_{-j} \\ \\sim \\ q(z_{-j})}[\\log P(\\boldsymbol{x,z})] \\ dz_j \\cr \u0026amp;= \\E_{z_j \\ \\sim \\ q_{\\phi_j}(z_j)}[\\E_{z_{-j} \\ \\sim \\ q(z_{-j})}[\\log P(\\boldsymbol{x, z})]] \\label{eq:17}\\tag{17}\\cr \\end{align} $$\nUsing equation ($\\ref{eq:16}, \\ref{eq:17}$), our ELBO($q(\\boldsymbol{z})$) will be,\n$$ \\begin{align} \\newcommand{\\E}{\\mathbb E} ELBO(q(\\boldsymbol{z})) \u0026amp;= \\quad \\E_{z_j \\ \\sim \\ q_{\\phi_j}(z_j)}[\\E_{z_{-j} \\ \\sim \\ q_{\\phi_{-j}}(z_{-j})}[\\log P(\\boldsymbol{x, z})]] \\cr \u0026amp; \\quad - \\ \\ \\E_{z_j \\ \\sim \\ q_{\\phi_j}(z_j)}[\\log q_{\\phi_j}(z_j)] \\ - \\ \\text{const} \\cr \u0026amp;= \\quad \\E_{z_j}[\\E_{z_{-j}}[\\log P(\\boldsymbol{x, z})] \\ - \\ \\log q_{\\phi_j}(z_j)]] \\ - \\ \\text{const} \\label{eq:18}\\tag{18}\\cr \\end{align} $$\nComing back to our goal of doing all these calculations, we would like to maximize the value of ELBO. Now, to find the value for which a function gives maximum we do differentiation of that function an find stationary points or in simple words keep it equal to zero. Since we have decomposed the $q(\\boldsymbol{z})$ into independent variational density functions,\nwe want\n(19) q \u0026#x3D5; 1 \u0026#x2217; , q \u0026#x3D5; 2 \u0026#x2217; , . . . , q \u0026#x3D5; m \u0026#x2217; = arg \u0026#x2061; max q \u0026#x3D5; 1 , q \u0026#x3D5; 2 , . . . , q \u0026#x3D5; m E L B O ( q ) Now, while optimizing one of the variational density function $q_{\\phi_j}$, we fixed the other variational factors/density functions $q_{\\phi_{-j}}$, such that the optimization of former doesnt\u0026rsquo; depend on latter in any case. Using this understanding we can independently optimize each variational factor.\n$$ \\begin{align} q_{\\phi_j}^{*} = \\arg \\max_{q_{\\phi_j}} ELBO(q_{\\phi_j}) \\label{eq:20} \\tag{20}\n\\end{align} $$\nLets\u0026rsquo; expand the ELBO($q(\\boldsymbol{z})$), using equation ($\\ref{eq:18}$)\nE L B O ( q \u0026#x3D5; j ( z j ) ) = \u0026#x222B; z j q \u0026#x3D5; j ( z j ) [ E z \u0026#x2212; j \u0026#xA0; \u0026#x223C; \u0026#xA0; q \u0026#x3D5; \u0026#x2212; j ( z \u0026#x2212; j ) [ log \u0026#x2061; P ( x , z ) ] \u0026#x2212; log \u0026#x2061; q \u0026#x3D5; j ( z j ) ] \u0026#x23DF; Functional(function of a function) \u0026#xA0; d z j \u0026#x2212; const Through optimization we would like to obtain optimal variational factor $q_{\\phi_j}^{*}(z_j)$, but this function is itself dependent on $z_j$. For some $z_j$ we can have many different members of variational family giving maximum ELBO and that is why its\u0026rsquo; functional or some researchers say function of a function. This cannot be optimized using regular derivative, but functional derivative.\nWe will not go into the depths of functional derivative in this blog. Although, Euler-Langrange equation can be used to solve this. This equation states that,\n$$ \\begin{align} \\displaystyle \\frac{\\partial F}{\\partial f} - \\frac{d}{dx} \\frac{\\partial F}{\\partial f\u0026rsquo;} = 0 \\end{align} $$\nwhere,\n$F$ is Functional and is equal to $q_{\\phi_j}(z_j)[\\mathbb{E_{z_{-j}\\ \\sim \\ q_{\\phi_{-j}}(z_{-j})}}[\\log P(\\boldsymbol{x}, \\boldsymbol{z})] - \\log q_{\\phi_j}(z_j)]$ $f$ is function that we want to optimize over, here its\u0026rsquo; $q_{\\phi_j}(z_j)$ $f\u0026rsquo;$ is derivative of $f$ Note, $\\displaystyle \\frac{\\partial F}{\\partial f\u0026rsquo;} = 0$, since $F$ doesnt\u0026rsquo; contain any term that has differentiation of $q_{\\phi_j}(z_j)$. So, only $\\displaystyle \\frac{\\partial F}{\\partial f}$ is left and it will be equal to zero.\n$$ \\begin{align} \\newcommand{\\E}{\\mathbb E} \\displaystyle {\\partial F \\over \\partial q_{\\phi_j}(z_j)} \u0026amp;= \\displaystyle {\\partial \\over \\partial q_{\\phi_j}(z_j)} \\Big[q_{\\phi_j}(z_j)[\\E_{z_{-j}}[\\log P(\\boldsymbol{x,z})] \\ - \\ \\log q_{\\phi_j}(z_j)]\\Big] \\cr 0 \u0026amp;= \\E_{z_{-j}}[\\log P(\\boldsymbol{x,z})] \\ - \\ \\log q_{\\phi_j}(z_j) \\ - \\ 1 \\cr q_{\\phi_j}^{*}(z_j) \u0026amp;= e^{\\E_{z_{-j}}[\\log P(\\boldsymbol{x,z})] \\ - \\ 1} \\cr \u0026amp;\\propto e^{\\E_{z_{-j}}[\\log P(\\boldsymbol{x,z})]} \\label{eq:21}\\tag{21} \\end{align} $$\nLets\u0026rsquo; have a look to a visualization regarding what all we have learned so far,\nVariational Inference Optimization for Variational FamilyIn this visualization we have variational family space consisting of three members of some density function. We choose randomly one family of three and then randomly initialized some clusters for e.g. K=2 in Q1, K=3 in Q2. Optimization than gave us variational parameters of these variational factors which closes up to posterior.\n\u0026#34;\u0026#34;\u0026#34; Coordinate ascent variational inference (CAVI) Algorithm \u0026#34;\u0026#34;\u0026#34; Input -\u0026gt; A model P(x, z), a dataset x Output -\u0026gt; A variational density q(z) = q1(z1)...qm(zm) Initialize -\u0026gt; Variational factors qj(zj) while ELBO(t+1)-ELBO(t) \u0026gt;= Œ¥: # converge for j in range(1, m+1): qj(zj) ‚àù exp{E{-j} [log P(z, x)]} # set ELBO(q) = E[log P(z, x)] - E[log q(z)] # compute return q(z) Practicalities Lets\u0026rsquo; talk about few things to keep in mind while implementing and using variational inference in practice.\nInitialization The ELBO is (generally) a non-convex objective function and hence, there can exist exponential number of local optimums. CAVI only guarantees convergence to a local optimum, which can be sensitive to initialization.\nELBO trajectory of 10 random initializations using Gaussian mixture model. Means of each variational factor is randomly sampled from another Gaussian distribution. Different initializations may lead CAVI to find different local optima of the ELBO\nAssessing Convergence We typically assess convergence once the change in ELBO has fallen below some small threshold. However, computing ELBO of the full dataset may be undesirable. Instead, its\u0026rsquo; suggested to compute the average log predictive of a small held-out dataset.\nNumerical Stability Probabilities are constrained to live within [0, 1]. Precisely manipulating and performing arithmetic of small numbers require additional care. Thats\u0026rsquo; why its\u0026rsquo; recommended to work with logarithms of probabilities. One useful trick is log-sum-exp trick,\n$$ \\begin{align} \\log \\Big[\\sum_i e^{x_i}\\Big] \u0026amp;= \\alpha + \\log \\Big[\\sum_ie^{x_i-\\alpha}\\Big] \\label{eq:22}\\tag{22} \\end{align} $$\nwhere, $\\alpha = \\max\\limits_i x_i$\nA complete example: Bayesian mixture of Gaussians In this section we are going to account the above concepts in order to set yet another example on bayesian mixture of Gaussians. So, we will first start notating the variables even though not much is going to change from what we notated in Bayesian mixture of Gaussians.\nConsider $K$ mixture components and $n$ real-valued data points $x_{1:n}$. The latent variables are $K$ real-valued mean parameters $\\boldsymbol{\\mu} = \\mu_{1:K}$ and $n$ latent-class assignments $\\boldsymbol{c} = c_{1:n}$. Assignment $c_i$ indicates which latent cluster $x_i$ comes from. As usual, $c_i$ is $K$-vector indicator just like earlier. There is fixed hyperparameter $\\sigma^2$, the variance of the normal prior on the $\\mu_k$. We assume observation variance is $\\boldsymbol{1}$.\nRecall from equation ($\\ref{eq:15}$), there are two type of variational parameters- categorical parameters $\\psi_i$ for approximating posterior cluster assignment of the $i^{th}$ datapoint and Gaussian parameters $m_k$ and $s_{k}^{2}$ for approximating the posterior of the $k^{th}$ mixture component.\nLets\u0026rsquo; find ELBO($q(\\boldsymbol{m}, \\boldsymbol{s^2}, \\boldsymbol{\\psi})$) by omitting latent variables.\n$$ \\newcommand{\\E}{\\mathbb E} \\begin{align} \\mathscr{L}(q(\\boldsymbol{m, s^2, \\psi})) \u0026amp;= \\quad \\E_{\\boldsymbol{m, s^2, \\psi} \\ \\sim \\ q(\\boldsymbol{m, s^2, \\psi})} [\\log P(\\boldsymbol{x, m, s^2, \\psi})] \\cr \u0026amp; \\quad - \\ \\ \\E_{\\boldsymbol{m, s^2, \\psi} \\ \\sim \\ q(\\boldsymbol{m, s^2, \\psi})} [\\log q(\\boldsymbol{m, s^2, \\psi})] \\cr \u0026amp;= \\quad \\E \\Big[\\log P(\\boldsymbol{\\mu; m, s^2})\\Big] \\cr \u0026amp; \\quad + \\ \\ \\E\\Big[\\log\\prod_{i=1}^nP(c_i;\\psi_i)P(x_i\\vert c_i, \\boldsymbol{\\mu}; \\psi_i, \\boldsymbol{m, s^2})\\Big] \\tag{eq. 6}\\cr \u0026amp; \\quad- \\ \\ \\E\\Big[\\log \\prod_{k=1}^Kq_{\\phi_k}(\\mu_k;m_k, s_k^2)\\prod_{i=1}^nq(c_i; \\psi_i)\\Big] \\tag{eq. 15}\\cr \u0026amp;= \\quad \\E[\\log P(\\boldsymbol{\\mu; m, s^2})] + \\sum_{i=1}^n\\E[\\log P(c_i; \\psi_i)] \\cr \u0026amp; \\quad + \\ \\ \\sum_{i=1}^n\\E[\\log P(x_i \\vert c_i, \\boldsymbol{\\mu}; \\psi_i, \\boldsymbol{m, s^2})] \\cr \u0026amp; \\quad - \\ \\ \\sum_{i=1}^n \\E[\\log q(c_i;\\psi_i)] - \\sum_{k=1}^K \\E[\\log q_{\\phi_k}(\\mu_k; m_k, s_k^2)] \\label{eq:23}\\tag{23}\\cr \\end{align} $$\nWhere, $\\mathscr{L}$ is variational energy/ELBO (just different name and notations but same quantity). Using equations ($\\ref{eq:6}, \\ref{eq:15}$) we expanded the $\\log$ quantities. We got equation ( 23 ) by combining the joint and mean-field family to form the ELBO for mixture of Gaussians, and it is function of variational parameters $\\boldsymbol{m, s^2}$, and $\\boldsymbol{\\psi}$. Here, each expectation can be computed in closed form.\nCAVI algorithm first derive the update for the variational cluster assignment factor $\\boldsymbol{\\psi}$; second, it derives the update for the variational component factor $\\boldsymbol{\\mu, s^2}$.\nVariational density of mixture assignments Before deriving the variational update for the cluster assignment $c_i$, lets\u0026rsquo; do some preliminary calculations using equation ($\\ref{eq:21}$).\nwe have on the right hand side,\n$$ \\begin{align} \\newcommand{\\E}{\\mathbb E} \\E_{z_{-j}} [\\log P(\\boldsymbol{x, z})] \u0026amp;= \\E_{z_{-j} \\ \\sim \\ q_{\\phi_{-j}}(z_{-j})}[\\log P(\\boldsymbol{x} \\vert \\boldsymbol{z})P(\\boldsymbol{z})] \\cr \u0026amp;= \\E_{z_{-j}}[\\log P(\\boldsymbol{x} \\vert \\boldsymbol{z})] + \\overbrace{\\E_{z_{-j}}[\\log P(z_j)P(z_{-j})]}^{z_i \\text{ is independent to } z_k, \\ k \\ne i} \\cr \u0026amp;= \\E_{z_{-j}}[\\log P(\\boldsymbol{x} \\vert \\boldsymbol{z})] + \\overbrace{\\log P(z_j)}^{\\text{const wrt } z_{-j}} + \\overbrace{\\text{const}}^{z_{-j} \\text{ is fixed}} \\label{eq:24}\\tag{24} \\cr \\implies q^{*}(z_j) \u0026amp;\\propto e^{\\E_{z_{-j}}[\\log P(\\boldsymbol{x} \\vert \\boldsymbol{z})] + \\log P(z_j)} \\label{eq:25}\\tag{25} \\end{align} $$\nUsing equation ($\\ref{eq:25}$) we can derive the variational update for the cluster assignment $c_i$ like this,\n$$ \\newcommand{\\E}{\\mathbb E} \\begin{align} q^{*}(c_i; \\psi_i) \\propto e^{\\log P(c_i) + \\overbrace{\\E[\\log P(x_i \\vert c_i, \\boldsymbol{\\mu;m,s^2})]}^{\\text{only } x_i \\text{ corresponds to } _i}} \\label{eq:26}\\tag{26} \\end{align} $$\nIn the above equation, we want to find variational update only for $c_i$, hence accounting $x_{-i}$ would not be essential. Assignment update may also depend on all the clusters\u0026rsquo; variational parameters like mean and variance, so we accounting $\\boldsymbol{\\mu}$.\n$\\log P(c_i)$ is log prior of $c_i$ and is same for all possible values of $c_i$, $\\log P(c_i) = -\\log K$. Second term is the expected $\\log$ of the $c_i^{th}$ Gaussian density. Since $c_i$ is indicator vector, we can write\n$$ \\begin{align} P(x_i \\vert c_i, \\boldsymbol{\\mu}) = \\prod_{k=1}^KP(x_i \\vert \\mu_k)^{c_{ik}} \\label{eq:27}\\tag{27} \\end{align} $$\nWe can use this to compute the expected log probability,\n$$ \\begin{align} \\newcommand{\\E}{\\mathbb E} \\E_{c_i, \\boldsymbol{\\mu} \\ \\sim \\ q(c_i, \\boldsymbol{\\mu})}[\\log P(x_i \\vert c_i, \\boldsymbol{\\mu})] \u0026amp;= \\sum_{k=1}^K c_{ik} \\E_{c_i, \\boldsymbol{\\mu} \\ \\sim \\ q(c_i, \\boldsymbol{\\mu})}[\\log P(x_i \\vert \\mu_k);m_k,s_k^2] \\cr \u0026amp;= \\sum_{k=1}^Kc_{ik}\\E\\Big[\\log \\frac{1}{\\sqrt{2\\pi}\\sigma}e^{-\\frac{(x_i-\\mu_k)^2}{2\\sigma}};m_k,s_k^2\\Big] \\cr \u0026amp;= \\sum_{k=1}^Kc_{ik}\\E\\Big[\\frac{(x_i-\\mu_k^2)}{2};m_k,s_k^2\\Big] + \\text{const} \\cr \u0026amp;= \\quad \\sum_{k=1}^Kc_{ik} \\Big(\\E[\\mu_k;m_k,s_k^2]x_i-\\E[\\frac{\\mu_k^2;m_k,s_k^2}{2}]\\Big) \\cr \u0026amp; \\quad + \\ \\ \\text{const} \\label{eq:28}\\tag{28}\\cr \\end{align} $$\nLooking at equation ($\\ref{eq:4}$) we can see that $P(x_i \\vert \\mu_k)$ corresponds to Gaussian distribution. Initially variance is set to 1, but during variational update it will be updated, right now we just need to know expression using which we can update. Equation ($\\ref{eq:28}$) requires the calculation of $\\mathbb{E}[\\mu_k]$ and $\\mathbb{E}[\\mu_k^2]$ for each mixture component, both computable from variational Gaussian on the $k^{th}$ mixture component.\nThus the variational update for the $i^{th}$ cluster assignment is,\n$$ \\begin{align} \\newcommand{\\E}{\\mathbb E} \\displaystyle \\psi_{ik} \\propto \\displaystyle e^{\\displaystyle \\E[\\mu_k;m_k,s_k^2]x_i-\\displaystyle \\frac{\\E[\\mu_k^2;m_k,s_k^2]}{2}} \\label{eq:29}\\tag{29} \\cr \\end{align} $$\n$\\psi_{ik}$ is the probability that the $i^{th}$ observation comes from the $k^{th}$ cluster. So it is only a function of the variational parameters for the mixture of components.\nWe can also write a vectorized version of $\\boldsymbol{\\psi}$ in this way,\n$$ \\newcommand{\\E}{\\mathbb E} \\begin{align} \\boldsymbol{\\psi} \\propto \\displaystyle e^{\\displaystyle \\boldsymbol{c}\\Big(\\boldsymbol{x}\\E[\\boldsymbol{\\mu}; \\boldsymbol{m, s^2}] - \\frac{\\E[\\boldsymbol{\\mu^2}; \\boldsymbol{m, s^2}]}{2}\\Big)} \\end{align} $$\nVariational density of the mixture-component means Again using equation (\\ref{eq:25}) we write down the joint density upto normalizing constant,\n$$ \\newcommand{\\E}{\\mathbb E} \\begin{align} \\displaystyle{q(\\mu_k) \\propto e^{\\log P(\\mu_k) + \\overbrace{\\sum_{i=1}^n\\E[\\log P(x_i \\vert c_i, \\boldsymbol{\\mu}); \\psi_i,m_{-k}, s_{-k}^2]}^{x_i \\text{ can be sampled from any } \\mu_k}}} \\label{eq:30}\\tag{30} \\cr \\end{align} $$\nWe now calculate the unnormalized $\\log$(since, no normalization factor on RHS) of this coordinate-optimal $q(\\mu_k)$. Also, $c_i$ is an indicator vector, so $\\psi_{ik} = \\E[c_{ik};\\psi_i]$. Now,\n$$ \\newcommand{\\E}{\\mathbb E} \\begin{align} \\log q(\\mu_k) \u0026amp;= \\log P(\\mu_k) + \\sum_{i=1}^n\\E_{\\mu_{-k}}[\\log P(x_i \\vert c_i, \\boldsymbol{\\mu}); \\psi_i, m_{-k}, s_{-k}^2] + \\text{const} \\cr \u0026amp;= \\log P(\\mu_k) + \\sum_{i=1}^n \\E_{\\mu_{-k}} [c_{ik}\\log P(x_i \\vert \\mu_k); \\psi_i] + \\text{const} \\cr \u0026amp;= \\log \\frac{1}{\\sqrt{2\\pi}\\sigma}e^{-\\frac{(0-\\mu_k)^2}{2\\sigma^2}} + \\sum_{i=1}^n \\E[c_{ik};\\psi_i] \\log P(x_i \\vert \\mu_k) + \\text{const} \\cr \u0026amp;= -\\frac{\\mu_k^2}{2\\sigma^2} + \\sum_{i=1}^n \\psi_{ik} \\Big(-\\frac{(x_i-\\mu_k)^2}{2}\\Big) + \\text{const} \\cr \u0026amp;= -\\frac{\\mu_k^2}{2\\sigma^2} + \\sum_{i=1}^n \\Big[\\psi_{ik}x_i\\mu_k - \\psi_{ik}x_i\\frac{\\mu_k^2}{2}\\Big] + \\text{const} \\cr \u0026amp;= \\Big(\\sum_{i=1}^n \\psi_{ik}x_i\\Big)\\mu_k - \\Big( \\frac{1}{2\\sigma^2} + \\sum_{i=1}^n\\frac{\\psi_{ik}}{2}\\Big)\\mu_k^2 + \\text{const} \\label{eq:31}\\tag{31}\\cr \\end{align} $$\nLets\u0026rsquo; not forget that our goal is still to maximize ELBO but by finding the variational update for $m_k, s_k^2, \\psi_{ik}$. And for finding the value of these varational factors that will maximize ELBO(q($m_k, s_k^2, \\psi_{ik}$)), we need to differentiate the above expression and keep it equal to 0.\nLets\u0026rsquo; first take derivative with respect to $\\mu_k$.\n$$ \\begin{align} \\frac{\\partial }{\\partial \\mu_k} \\log q(\\mu_k) \u0026amp;= 0 \\cr \\Big(\\sum_{i=1}^n \\psi_{ik}x_i\\Big) - \\Big( \\frac{1}{\\sigma^2} + \\sum_{i=1}^n\\psi_{ik}\\Big)\\mu_k \u0026amp;= 0 \\cr \\mu_k = m_k \u0026amp;= \\boxed{{\\sum_{i=1}^n \\psi_{ik}x_i \\over {\\frac{1}{\\sigma^2} + \\sum_{i=1}^n\\psi_{ik}}}} \\label{eq:32}\\tag{32}\\cr \\end{align} $$\nSimilarly for $s_k^2$,\n$$ \\begin{align} s_k^2 = \\boxed{\\frac{1}{\\frac{1}{\\sigma^2} + \\sum_{i=1}^n\\psi_{ik}}} \\label{eq:33}\\tag{33} \\end{align} $$\nThe coordinate optimal variational density of $\\mu_k$ belongs to exponential family of distribution, where sufficient statistics ${ \\mu_k, \\mu_k^2 }$ and natural parameters ${ \\sum_{i=1}^n \\psi_{ik}x_i, -\\frac{1}{2\\sigma^2}-\\sum_{i=1}^n \\frac{\\psi_{ik}}{2} }$. This shows its\u0026rsquo; a Gaussian distribution.\n\u0026#34;\u0026#34;\u0026#34; CAVI for a Gaussian mixture model \u0026#34;\u0026#34;\u0026#34; Input -\u0026gt; x(1:n), K, prior variance œÉ^2 Output -\u0026gt; q(¬µ_k; m_k, s_k^2) (Gaussian) and q(c_i; œà_i) (K-categorical) Initialize -\u0026gt; m(1:K), s^2(1:K), œà_i(1:n) while ELBO(t+1)-ELBO(t) \u0026gt;= Œ¥: # converge for i in range(1, n+1): œà_ik ‚àù exp{E[¬µ_k; m_k, s_k^2]x_i - E[¬µ_k^2; m_k, s_k^2]/2} # set for k in range(1, K+1): m_k \u0026lt;- equation 32 # set s_k^2 \u0026lt;- equation 33 # set ELBO[m, s^2, œà] # compute return q(m, s^2, œà) Great, now lets\u0026rsquo; talk about some benefits along with limitations of Variational Inference.\nBenefits Faster to converge than MCMC and easier to scale to large data Applied to real world problems like :- Large-scale doument analysis Computational Neuroscience Computer Vision Because its\u0026rsquo; optimization problem, usage of stochastic optimization along with comes handy Doesnt\u0026rsquo; suffer in accuracy, i.e. in terms of posterior predictive densities This is why, variational inference is suitable for problems that contain large datasets and we want to quickly explore many models. For e.g. fitting a probabilistic model of image to millions or billions of images.\nLimitations Studied less rigorously than MCMC due to which we havent\u0026rsquo; been able to uleash its\u0026rsquo; full potential It doesnt\u0026rsquo; provide asymptotic guarantees of convergence, but only find density close to target Conclusion We started with defining and understanding the core problem in bayesian statistics or regarding predictive analysis in general. From there we found two approaches to solve this problem, one is Monte Carlo Markov Chain (MCMC) technique regarding whih we had brief discussion and another is Varational Inference which is the center of attraction for this article. MCMC method has been in use since before variational inference was even introduced, so we talked about about the shortcomings of former for th introduction of latter. Now, from ground-up we talked about variational inference using derivations and examples from mixture of Gaussians. Variational Inference is definitely a path forward that we can see by the ubiquity of machine learning methods like VAEs.\n$$\\color{#A91B0D}\\text{Thankyou for your time and patience}$$\nCitation Cited as:\nGarg, P. (2023, May 11). Autoregressive Models: Connecting the Dots. Eulogs. Retrieved May 11, 2023, from https://www.eulogs.com/posts/variational-inference-the-path-forward/\nor\n1 2 3 4 5 6 7 8 @article{garg_2023, title = \u0026#34;Variational Inference: The Path Forward\u0026#34;, author = \u0026#34;Garg, Priyam\u0026#34;, journal = \u0026#34;www.eulogs.com\u0026#34;, year = \u0026#34;2023\u0026#34;, month = \u0026#34;May\u0026#34;, url = \u0026#34;https://www.eulogs.com/posts/variational-inference-the-path-forward/\u0026#34; } References [1] Blei, D. M., Kucukelbir, A., \u0026amp; McAuliffe, J. (2016). Variational Inference: A Review for Statisticians. Journal of the American Statistical Association, 112(518), 859‚Äì877. https://doi.org/10.1080/01621459.2017.1285773\n[2] Van Ravenzwaaij, D., Cassey, P., \u0026amp; Brown, S. D. (2018). A simple introduction to Markov Chain Monte‚ÄìCarlo sampling. Psychonomic Bulletin \u0026amp; Review, 25(1), 143‚Äì154. https://doi.org/10.3758/s13423-016-1015-8\n[3] Tomczak, J. M. (2022). Deep Generative Modeling. Springer Nature\n","permalink":"https://www.eulogs.com/posts/variational-inference-the-path-forward/","summary":"üö® Heavy Math Ahead The following article features maths on steroids, which could delay your page load time. Recommended to refresh once. We apologize for the inconvenience. Science does not aim at establishing immutable truths and eternal dogmas; its aim is to approach the truth by successive approximations, without claiming that at any stage final and complete accuracy has been achieved.\n\u0026ndash;Bertrand Russell\nMotivation Lets\u0026rsquo; recall the Bayes theorem that most of us might already be familiar with, it goes like $P(A \\vert B) = \\displaystyle \\frac{P(B \\vert A)P(A)}{P(B)}$.","title":"Variational Inference: The Path üõ£Ô∏è Forward"},{"content":" The future will soon be a thing of past\n\u0026ndash;George Carlin\nBlogpost will talk about need and what of Autoregressive models, but before going towards the what, its\u0026rsquo; better to first understand why we felt the need to have another type of models in machine learning community. We will look at the Motivation behind the creation and what problems we want to solve using them.\nMotivation Problems we would like to solve Generating Data: syntheizing images, text, videos, speech Compressing data: constructing efficient codes. Anomaly Detection: e.g. supervised estimator is forced to make a decision even over the datapoint it is uncertain about Suppose there exist true data distribution \\(p_{data}(\\textbf{x})\\), now you most probably will not be able to know this distribution but what you can do is sample some data points from it \\(\\textbf{x}^{(1)}, \\textbf{x}^{(2)} \u0026hellip; \\textbf{x}^{(n)} \\sim p_{data}(\\textbf{x})\\). Now likelihood based models try to estimate this \\(p_{data}\\) by finding a distribution that closely fits to the datapoints sampled. But likelihood function we try to find should basically find probability \\(p(\\textbf{x})\\) for any arbitrary \\(\\textbf{x}\\) such that it will actually closely fits to true distribution and not just sampled distribution, and also be able to sample \\(\\textbf{x} \\sim p(\\textbf{x})\\)\nIts\u0026rsquo; important to note that just because we can sample from distribution so we can compute it too or just because we can compute the distribution then we can sample from it too. But using Autoregressive models we will be able to do both, and actually computing probability will be lot easier than generating samples.\nDesiderata We want to estimate distribution of complex high dimenional data, lets\u0026rsquo; say you have an image of \\(128\\times 128\\times 3\\) which will correspond to \\(\\sim \\textbf{50,000}\\) pixels(or dimensions). And its\u0026rsquo; just not for one image datapoint but whole lot of dataset.\nTo learn such high dimensional data we need computationl and statistical efficiency. Think of computational efficiency as operation should not take much time and statistical efficiency as it should not take whole lot of datapoints to start understanding the patterns in the datapoints with whatever model we use.\nEfficient training(computationally and statistically) and model representation Expressiveness and Generalization Sampling quality and speed Compression rate and speed Function Approximation Our goal is to estimate true distribution \\(p_{data}\\) using sampled datapoints \\(\\textbf{x}^{(1)}, \\textbf{x}^{(2)} \u0026hellip; \\textbf{x}^{(n)} \\sim p_{data}(\\textbf{x})\\). So we introduce function approximation which will learn the weights/parameters \\(\\theta\\) of the likelihood function(here, Neural Network) such that \\(p_{\\theta}(\\textbf{x}) \\approx p_{data}(\\textbf{x})\\).\n‚ùìQuestion How do we design such function approximators to effectively represent complex joint distributions over x, yet remain easy to train? Now, when we train neural nets what we are actually doing is finding the best weights for the model in order to find best likelihood function. So, designing the model and training procedure go hand in hand. And thi pose a search problem over the parameters. $$\\arg \\min_{\\theta} \\textbf{loss}(\\theta, \\textbf{x}^{(1)}, \u0026hellip; ,\\textbf{x}^{(n)})$$ For intutive understanding, think of likelihood function to be Gaussian Distribution and \\(\\theta\\) be its mean and variance. So, while training \\(\\theta\\) will keep updating in order to fit some distribution.\nMost likely objective we use is Maximum Likelihood $$\\arg \\min_{\\theta} loss(\\theta, \\textbf{x}^{(1)}, \u0026hellip;, \\textbf{x}^{(n)}) = \\frac{1}{n} \\sum_{i=1}^{n}-\\log p_{\\theta}(\\textbf{x}^{(i)})$$ It is interesting to note that minimizing KL Divergence is asymptotically equivalent to maximizing the likelihood.\n‚ùìHow minimizing KL Divergence asymptotically equivalent to maximizing the likelihood? Let there exist likelihood function for true distribution \\(P(x\\vert\\theta^{*})\\) and approximate function \\(P(x\\vert\\theta)\\) \\[\\begin{aligned} \\theta_{\\min KL} \u0026amp;= \\arg \\min_{\\theta}D_{KL}\\left[P(x\\vert\\theta^{*})\\Vert P(x\\vert\\theta)\\right] \\\\ \u0026amp;= \\arg \\min_{\\theta} \\mathbb{E}_{x \\sim P(x \\vert \\theta^{*})}\\left[\\log \\frac{P(x\\vert\\theta^{*})}{P(x\\vert\\theta)}\\right] \\end{aligned}\\] \\(P(x\\vert\\theta^{*})\\) is not going to contribute to the optimization and can be popped out of equation \\[\\begin{aligned} \\theta_{\\min KL} \u0026amp;= \\arg \\min_{\\theta} \\mathbb{E}_{x \\sim P(x \\vert \\theta^{*})}\\left[-\\log P(x\\vert\\theta)\\right] \\\\ \u0026amp;= \\arg \\max_{\\theta} \\mathbb{E}_{x \\sim P(x \\vert \\theta^{*})}\\left[\\log P(x\\vert\\theta)\\right] \\end{aligned}\\] Applying the law of large numbers, \\[\\begin{aligned} \\theta_{\\min KL} \u0026amp;= \\arg \\max_{\\theta} \\lim_{n \\rightarrow \\infty} \\frac{1}{n}\\sum_{i=1}^{n} \\log P(x_{i}\\vert \\theta) \\\\ \u0026amp;= \\arg \\max_{\\theta} \\log P(x \\vert \\theta) \\\\ \u0026amp;= \\arg \\max_{\\theta} P(x \\vert \\theta) \\\\ \u0026amp;= \\theta_{max MLE} \\end{aligned}\\]\nOkay, back to our search problem over parameters we found loss function as maximum likelihood but what procedure to follow for optimization? Stochastic Gradient Descent (SGD) seems to work just fine!\nSetting Bayes as base Let us a consider a high-dimensional random variable \\(\\textbf{x} \\in \\mathcal{X}^{D}\\) where \\(\\mathcal{X} = {0, 1, \u0026hellip;, 255}\\) (e.g. pixel values) or \\(\\mathcal{X}=\\mathbb{R}\\). Our goal is to model \\(p(\\textbf{x})\\). For intutive undertanding, say you have an image whose height and width are same as \\(\\sqrt{D}\\) which implies there would be \\(D\\) pixels or dimensions, each dimension can vary over \\(\\mathbb{R}\\). So to model image \\(\\textbf{x}\\) would be equivalent to model the joint distribution of all the pixels or dimensions of the image.\n$$ \\begin{aligned} p(x) \u0026amp;= p(x_{1}, x_{2},\u0026hellip;, x_{d}) \\cr \u0026amp;= p(x_{1})p(x_{2}\\vert x_{1})\u0026hellip;p(x_{D}\\vert x_{1},\u0026hellip;, x_{D-1}) \\cr \u0026amp;= p(x_{1})\\prod_{d=2}^{D}p(x_{d}\\vert x_{\u0026lt;d}) \\cr \\log p(x) \u0026amp;= \\boxed{p(x_{1})\\sum_{d=2}^{D}\\log p(x_{d}\\vert x_{\u0026lt;d})} \\end{aligned} $$\nThis is Autoregressive Model.\nModelling all conditional distribution separately is simplt infeasible! If we did that we would obtain \\(D\\) different models, and complexity of each model will grow to varying conditioning. Can we solve this issue? Yes, by using single, shared model for the all the conditional distributions and that can be done using neural network as that model.\nDeep Autoregressive Models Architectures Reearch community has mostly focused on improving the network architectures of deep autoregressive models [4], some areas they focused on are as follows:-\nIncreasing receptive field and memory: This ensured the network has access to all parts of the input to encourage consistency Increasing network capacity: Which allowed more complex distributions to be modelled. Taxonomy of Autoregressive Models\nIn the above figure we have tried to do as many plausible classifications of Autoregressive models, there can be more but in the community these are the important ones.\nWe are no going to learn any of those methods in this blogpost. In future, links to published blogs corresponding to those methods will be added here as list and you can access them directly. This will ease up the navigation process then may it be you want to access root(like in trees) blog post of Generative Modelling: Stormbreaker ü™ì in AI world series or any leaf blog post like LSTM.\nCitation Cited as:\nGarg, P. (2023, May 2). Autoregressive Models: Connecting the Dots. Eulogs. Retrieved May 2, 2023, from https://www.eulogs.com/posts/autoregressive-models-connecting-the-dots/\nor\n1 2 3 4 5 6 7 8 @article{garg_2023, title = \u0026#34;Autoregressive Models: Connecting the dots\u0026#34;, author = \u0026#34;Garg, Priyam\u0026#34;, journal = \u0026#34;www.eulogs.com\u0026#34;, year = \u0026#34;2023\u0026#34;, month = \u0026#34;May\u0026#34;, url = \u0026#34;https://www.eulogs.com/posts/autoregressive-models-connecting-the-dots/\u0026#34; } References [1] Pieter Abbeel. (2020, February 5). L2 Autoregressive Models \u0026ndash; CS294-158-SP20 Deep Unsupervised Learning \u0026ndash; UC Berkeley, Spring 2020 [Video]. YouTube. https://www.youtube.com/watch?v=iyEOk8KCRUw\n[2] Tae, J. (2020a, March 9). Jake Tae. MLE and KL Divergence. https://jaketae.github.io/study/kl-mle/\n[3] Tomczak, J. M. (2022). Deep Generative Modeling. Springer Nature\n[4] Bond-Taylor, S., Leach, A., Long, Y., \u0026amp; Willcocks, C. G. (2021). Deep Generative Modelling: A Comparative Review of VAEs, GANs, Normalizing Flows, Energy-Based and Autoregressive Models. IEEE Transactions on Pattern Analysis and Machine Intelligence, 44(11), 7327‚Äì7347. https://doi.org/10.1109/tpami.2021.3116668\n","permalink":"https://www.eulogs.com/posts/autoregressive-models-connecting-the-dots/","summary":"The future will soon be a thing of past\n\u0026ndash;George Carlin\nBlogpost will talk about need and what of Autoregressive models, but before going towards the what, its\u0026rsquo; better to first understand why we felt the need to have another type of models in machine learning community. We will look at the Motivation behind the creation and what problems we want to solve using them.\nMotivation Problems we would like to solve Generating Data: syntheizing images, text, videos, speech Compressing data: constructing efficient codes.","title":"Autoregressive Models: Connecting the Dots"},{"content":" Through this blogpost we are going to gain in-depth understanding of Generative Models, why we need them, along with current taxanomy. But before diving into the Why?, What? of Generative Models, let us consider a simple example of trained Deep Neural Network(DNN) that classifies images of animals. Although the network is trained so well but adding noise to image could output false classification, even though noise added to image doesn\u0026rsquo;t change the semantics under human perception. This example indicates that neural networks that are used to parameterize the conditional distribution \\(p(y|\\textbf{x})\\) seem to lack semantic understanding of images. A useful model in real world will not only output probability of correctness of classification for example but will be able to tell its level of uncertainity for the answer.\nWhy Generative Modelling? Deep Learning models cannot go on making decision about the problems without understanding the reality, and express uncertainity about surrounding world. Assume we have some two-dimensional data and new data-point to be classified. Now, there are two approaches we can use to solve this problem. First, classifier could estimate the result by modelling conditional distribution \\(p(y|\\textbf{x})\\). Second, we can consider joint distribution \\(p(\\textbf{x}, y)\\) that could be further decomposed as \\(p(\\textbf{x}, y)=p(y|\\textbf{x})p(\\textbf{x})\\).\nAnd example of data (left) and two approaches to decision making: (middle) a discriminative approach and (right) a generative approach\nIn the above figure, both the approaches i.e. discriminative and generative have made a decision boundary. On one hand former is quite certain of \u0026ldquo;X\u0026rdquo; being a part of blue region whereas latter uses \\(p(\\textbf{x})\\) to account for additional understanding. Now, \u0026ldquo;X\u0026rdquo; lies far from orange zone, but also does not lie in the region of high probability mass in blue zone due to which generative approach said \\(p(\\textbf{x})\\) as low. And, if we want these models to be communicative enough such that as humans we can understand why thy are making decisions that they are making, that would be a crucial skill to exploit.\nSignificance of p(x) From the generative perspective, knowing the distribution \\(p(\\textbf{x})\\) is essential because:\nIt could be used to assess whether a given object has been observed in past or not. It could help to properly weight the decision. It could be used to assess uncertainity about the environment. It could be used to actively learn by interacting with environment( e.g. by asking for labeling objects with low \\(p(\\textbf{x})\\)) It could be used to generate (syntheize) new objects. Though, some if not most of the readers might be ignorant to the use of \\(p(\\textbf{x})\\) only as generator of new data, but above points bring into varied perspectives of it. And at this point, the sail that once started from island of discriminative modelling brought us to the vast land of generative modelling.\nWhere Can we use (Deep) Generative Modelling? Deep Generative Modelling need high computational power for training and with the advent of GPU and Deep Learning Frameworks like PyTorch, TensorFlow etc we have seen vast applications thereof.\nSome applications vary from typical modalities considered in machine learning:-\nText Analysis: Question-Answering, Machine Translation, Text-to-Image Generation Image-Analysis: Data Augmentation, Super Resolution, Image Inpainting, Image Denoising, Object Transfiguration, Image Colorization, Image Captioning, Video Prediction etc. Audio Analysis: WaveNet Active Learning: Generate synthetic medical images, generate synthetic text data etc. Reinforcement Learning: World Models Graph Analysis: Understanding Interaction Dynamics in Social Networks, Anomaly Detection, Protein Structure Modelling, Source Code Generation, Semantic Parsing. How to Formulate (Deep) Generative Modelling? After asking some important questions of What and where, its\u0026rsquo; time to ask how. In other words we can understand the section heading as how to express \\(p(\\textbf{x})\\). We can divide (Deep) Generative modelling into four categories:- \\((1)\\) Autoregressive Generative Models(ARM) \\((2)\\) Flow-based Models \\((3)\\) Latent variable models \\((4)\\) Energy-based models\nA taxonomy of deep generative models\nDeep Generative models can be divided into two types of density estimation methods, namely \\((1)\\) Explicit Density Models \\((2)\\) Implicit Density Models. Say you have data distribution \\(p_{data}\\), \\(p_{model}(\\textbf{x};\\theta)\\) likelihood function which learns that data distribution and \\(\\textbf{x}=[x_{1}, x_{2}, \u0026hellip;, x_{n}]^{T}\\) are data-points of dataset. Now in explicit density models we compute \\(p_{model}(\\textbf{x};\\theta)\\) in short \\(p(\\textbf{x})\\), but in implicit models we dont\u0026rsquo; need to compute this likelihood function but directly sample from the distribution e.g. sampling values from noise, and generate for instance image samples using some transformation.\nExplicit Generative Methods Impliit Generative Methods define an explicit density form(\\(p_{model}(\\textbf{x};\\theta)\\)) that allows likelihood inference target a flexible transformation(Generator) from random noise to generated samples used to estimate the probability density function of the data can generate new samples from the learned distribution require computing the likelihood of the data, which can be computationally expensive do not require computing the likelihood typically easier to interpret and analyze more flexible and can capture complex distributions can suffer from overfitting can suffer from mode collapse trained using maximum likelihood estimation typically trained using adversarial training or variational inference Explicit Generative Methods Explicit density methods need to estimate the density of underlying data distribution and marginal likelihood in denominator of bayes rule \\(p(z|x)=\\frac{p(x,z)}{\\int p(x|z)p(z)}\\) creates problem since it involves integral. Now if this likelihood can be solved in closed-form expression then those problems lie under tractable density otherwise we need to find approximations to it and so those problems lie under approximate density class. Also, tractable density can be computed in polynomial time but intractable(not approximate) takes more than exponential time to solve. In the given link of Closed Form Expressions a table is given where you can check that we do not have any closed form solution under integral.\nTractable Generative Models In tractable density models we have two type of techniques namely \\((1)\\) Autoregressive Models \\((2)\\) Flow-based Models.\nAutoregressive Models Here, distribution over \\(\\textbf{x}\\) is represented in an autoregressive manner:\n$$p(\\textbf{x})=p(x_{0})\\prod_{i=1}^{D}p(x_{i}\\vert\\textbf{x}_{\u0026lt;i})$$\nwhere, \\(\\textbf{x}_{\u0026lt;i}\\) denotes all \\(\\textbf{x}\\)\u0026rsquo;s upto index \\(i\\).\nModelling all conditional distributions \\(p(x_{i}\\vert\\textbf{x}_{\u0026lt;i})\\) would be computationally inefficient. But there are many ways we solve this, although we will not talk about autoregessive models here. Checkout the post Autoregressive Models: Connecting the dots that talk about why we needed these type of models anyway along with its taxonomy.\nFlow-based Models The change of variable formula provides a principled manner of expressing a density of a random variable by transforming it with an invertible transformation \\(f\\).\n$$p(\\textbf{x})=p(z=f(x))\\vert\\text{J}_{f(\\textbf{x})}\\vert$$\nwhere \\(\\text{J}_{f(\\textbf{x})}\\) denotes the Jacobian Matrix.\nWe can parameterize \\(f\\) using deep neural networks; however, it cannot be any arbitrary neural networks, because we must be able to calculate the Jacobian matrix. All generative models that take advantage of change of variables formula are referred as flow-based models or flows for short.\nApproximate Generative Models In approximate density models we have two type of techniques namely \\((1)\\) Prescribed Models \\((2)\\) Energy-based Models.\nPrescribed Models The idea behind latent variable models is to assume a lower-dimensional latent space and the following generative process: $$\\textbf{z} \\sim p(\\textbf{z})$$ $$\\textbf{x} \\sim p(\\textbf{x}\\vert\\textbf{z})$$ Latent variables corresponds to hidden factor in data, and the conditional distribution \\(p(\\textbf{x}\\vert\\textbf{z})\\) could be treated as a generator.\nThe most widely known known latent variable model is probabilisitc Principal Component Analysis (pPCA) where \\(p(\\textbf{z})\\) and \\(p(\\textbf{x}\\vert\\textbf{z})\\) are Gaussian distibutions, and dependency between \\(\\textbf{z}\\) and \\(\\textbf{x}\\) is linear.\nA non-linear extension of pPCA with arbitratry distributions is the Variational Auto-Encoder (VAE) framework. In VAEs and the pPCA all distributions must be defined upfront and, therefore, they are called prescribed models.\nEnergy Based Models Physics provide an interesting perspective on defining a group of generative models through defining an energy function, \\(E(\\textbf{x})\\), and, eventually the Boltzmann distribution: $$p(\\textbf{x}) = \\frac{e^{-E(\\textbf{x})}}{Z}$$ where \\(Z=\\sum_{\\textbf{x}}e^{-E(\\textbf{x})}\\) is the partition function. \\(Z\\) normalizes the values of function.\nThe main idea behind EBMs is to formulate the energy function and calculate(or rather approximate) the partition function.\nImplicit Generative Methods GANs Above all described methods except EBMs used log-likelihood function for density estimation, but another approach uses adversarial loss where discriminator \\(D(\\cdot)\\) determines a difference between real data and synthetic data provided by the generator in the implicit form, these are Generative Adversaial Networks(GANs) under implicit models.\n‚ùóImportant It is to be noted that these groups dont' create hard demarcations and there are methods that use concepts from more than one groups for e.g. flow-based GAN model Overview Below is provided a table that shows comparision of all the four groups of methods on some arbitrary criteria like:-\nWhether training is typically stable? Whether it is possible to calculate likelihood function? Whether one can use a model for lossy or lossless compression? Whether a model can be used for Representation Learning? Generative Models Training Likelihood Sampling Compression Representation Autoregressive Stable Exact Slow Lossless No Flow-based Stable Exact Fast/Slow Lossless Yes Implicit Unstable No Fast No No Prescribed Stable Approximate Fast Lossy Yes Energy-based Stable Unnormalized Slow Rather not Yes Citation Garg, P. (2023a, April 30). Generative Modelling: Stormbreaker ü™ì in AI world. Eulogs. Retrieved May 2, 2023, from https://www.eulogs.com/posts/generative-modelling/\nor\n1 2 3 4 5 6 7 8 @article{garg_2023, title = \u0026#34;Generative Modelling: Stormbreaker ü™ì in AI world\u0026#34;, author = \u0026#34;Garg, Priyam\u0026#34;, journal = \u0026#34;www.eulogs.com\u0026#34;, year = \u0026#34;2023\u0026#34;, month = \u0026#34;Apr\u0026#34;, url = \u0026#34;https://www.eulogs.com/posts/generative-modelling/\u0026#34; } References [1] Tomczak, J. M. (2022). Deep Generative Modeling. Springer Nature\n[2] Wu, Q., Gao, R., \u0026amp; Zha, H. (2021). Bridging Explicit and Implicit Deep Generative Models via Neural Stein Estimators. In Neural Information Processing Systems (Vol. 34). https://papers.nips.cc/paper/2021/hash/5db60c98209913790e4fcce4597ee37c-Abstract.html\n[3] Bond-Taylor, S., Leach, A., Long, Y., \u0026amp; Willcocks, C. G. (2021). Deep Generative Modelling: A Comparative Review of VAEs, GANs, Normalizing Flows, Energy-Based and Autoregressive Models. IEEE Transactions on Pattern Analysis and Machine Intelligence, 44(11), 7327‚Äì7347. https://doi.org/10.1109/tpami.2021.3116668\n","permalink":"https://www.eulogs.com/posts/generative-modelling/","summary":"Through this blogpost we are going to gain in-depth understanding of Generative Models, why we need them, along with current taxanomy. But before diving into the Why?, What? of Generative Models, let us consider a simple example of trained Deep Neural Network(DNN) that classifies images of animals. Although the network is trained so well but adding noise to image could output false classification, even though noise added to image doesn\u0026rsquo;t change the semantics under human perception.","title":"Generative Modelling: Stormbreaker ü™ì in AI world"},{"content":" Condition Number A condition number measures how sensitive is the solution of equation(s) to perturbations in the input is.\nIntroduction Consider a system of linear equations in the form of \\(Ax=b\\), where we are interested to find \\(x\\). So we have a solution space of \\(x \\in R^{n}\\) for \\(b \\in R^{m}\\) while unchanging \\(A\\).\nNow our objective is to quantify the change in solution space of \\(x\\) if we add some perturbations or error term to input space of \\(b\\). As we can see in the above figure that altering the input space will give us $$A(x+\\Delta{x})=b+\\Delta{b}$$\nTe reach our objective, we first need to understand what are matrix norms.\nMatrix Norms The norm of square matrix \\(A\\) is non-negative real number denoted \\(\\lVert A \\rVert\\). It is a way of determining the \u0026ldquo;size\u0026rdquo; of a matrix that is not necessarily related to how many rows or columns the matrix has. There are various different ways of defining a matrix norm.\n1-Norm $$\\lVert A \\rVert_{1} = \\max_{1 \\le \\ j \\ \\le n}(\\sum_{i=1}^{n}|a_{ij}|)$$\nWe sum the absolute values down each column and then take the max value out of those.\nInfinity-Norm $$\\lVert A \\rVert_{\\infty} = \\max_{1 \\le \\ i \\ \\le n}(\\sum_{j=1}^{n}|a_{ij}|)$$\nWe sum the absolute values along each row and then take the max out of those.\nWe have taken square matrix \\(A\\) but same formulas can be applied for rectangular matrices too.\nProperties \\(\\lVert A \\rVert\\) \\(\\ge\\) 0 for any square matrix \\(\\lVert A \\rVert\\) \\(=\\) 0 iff \\(A=0\\) \\(\\lVert kA \\rVert\\) = |k|\\(\\lVert A \\rVert\\), for any scalar \\(k\\) \\(\\lVert A + B \\rVert \\le \\lVert A \\rVert + \\lVert B \\rVert\\) \\(\\lVert AB \\rVert \\le \\lVert A \\rVert \\lVert B \\rVert\\) Condition Number Matrix norm is enough for us to start working on condition number. We will start by accounting in \\(Ax=b\\) and \\(A(x+\\Delta{x})=b+\\Delta{b}\\).\n$$ \\begin{aligned} \\cancel{Ax} \u0026amp;= \\cancel{b} \\cr \\cancel{Ax}+A\\Delta{x} \u0026amp;= \\cancel{b} + \\Delta{b} \\cr \\hline \\cr A\\Delta{x} \u0026amp;= \\Delta{b} \\cr \\hline \\end{aligned} $$\napplying the \\(5^{th}\\) property of matrix norms to \\(Ax=b\\)\n$$ \\begin{aligned} \\lVert b \\rVert = \\lVert Ax \\rVert \u0026amp;\\le \\lVert A \\rVert \\lVert x \\rVert \\cr \\frac{1}{\\lVert x \\rVert} \u0026amp;\\le \\frac{\\lVert A \\rVert}{\\lVert b \\rVert} \\end{aligned} $$\nmultiplying \\(A\\Delta{x} = \\Delta{b}\\) by \\(A^{-1}\\) on both sides\n$$ \\begin{aligned} A^{-1}A\\Delta{x} \u0026amp;= A^{-1}\\Delta{b} \\cr I\\Delta{x} \u0026amp;= A^{-1}\\Delta{b} \\end{aligned} $$ taking matrix norm on both sides $$\\lVert \\Delta{x} \\rVert = \\lVert A^{-1}\\Delta{b} \\rVert \\le \\lVert A^{-1} \\rVert \\lVert \\Delta{b} \\rVert$$\nwe get, $$\\boxed{\\frac{\\lVert \\Delta{x} \\rVert}{\\lVert x \\rVert} \\le \\lVert A \\rVert \\lVert A^{-1} \\rVert \\frac{\\lVert \\Delta{b} \\rVert}{\\lVert b \\rVert}}$$ This says that the upper bound in relative error of \\(x\\) would be scaled to \\(\\kappa(A) = \\lVert A \\rVert \\lVert A^{-1} \\rVert\\) multiplied by relative error in \\(b\\), where \\(\\kappa(A)\\) is Condition Number. Calculating \\(\\lVert A \\rVert\\) is relatively easy than finding \\(\\lVert A^{-1} \\rVert\\).\n\\(\\Delta{b}\\) is usually generated by rounding error programs, or when we made some approximation mistake. Hence, it is quite small and this implies relative error in \\(x\\) depends on condition number. Also we generally use infinity-norm to find matrix norms of matrices.\nüìì Example Consider 5x1+7x2=0.75x_{1} + 7x_{2} = 0.7, 7x1+10x2=17x_{1} + 10x_{2} = 1 Solution x = [0, 0.1]\nPerturbed system 5x1+7x2=0.695x_{1} + 7x_{2} = 0.69, 7x1+10x2=1.017x_{1} + 10x_{2} = 1.01\nhas the solution x\u0026rsquo; = [-0.17, 0.22]\nThe relative error in the xx is given by, ‚à•Œîx‚à•‚à•x‚à•=1.7\\frac{\\lVert \\Delta{x} \\rVert}{\\lVert x \\rVert} = 1.7\nand the relative error in bb is given by, ‚à•Œîb‚à•‚à•b‚à•=0.01\\frac{\\lVert \\Delta{b} \\rVert}{\\lVert b \\rVert} = 0.01\nnow 1\u0026#37 error in input is giving a 170\u0026#37 error in output which is significantly large.\nLet‚Äôs check the condition number using the infinity norm. Œ∫(A)=289\\kappa(A) = 289\nThis says that the upper bound of relative error in solution space is 289x0.01=2.89289x0.01=2.89\nA matrix with large condition number is said to be ill conditioned. Whereas a matrix with small condition matrix is said to be well conditioned. Although large and small is hard to quantify since it depends on many factors of which some can be how powerful computing power we working with, what type of applications we are working with etc.\nüìè Theoram Let AA be a square non-singular matrix then for any singular matrix of the same size BB, we have 1Œ∫(A)‚â§‚à•A‚àíB‚à•‚à•A‚à•\\frac{1}{\\kappa(A)} \\le \\frac{\\lVert A - B\\rVert}{\\lVert A \\rVert} This shows that if you have singular matrix which is quite close to non-singular matrix then it will decrease the relative error but inversely decrease the condition number too. In other words, closer the singular matrix to non-singular matrix higher the condition number.\nüìì Example Consider a matrix B=(1111)B=\\begin{pmatrix} 1 \u0026amp; 1 \\\\ 1 \u0026amp; 1 \\end{pmatrix} which is singularly non-invertible since its determinant is 0.\nFor any œµ\u0026gt;0\\epsilon \\gt 0, let A=(11+œµ1‚àíœµ1)A=\\begin{pmatrix} 1 \u0026amp; 1+\\epsilon \\\\ 1-\\epsilon \u0026amp; 1 \\end{pmatrix} then, A‚àí1=œµ‚àí2(1‚àí1‚àíœµ‚àí1+œµ1)A^{-1} = \\epsilon^{-2}\\begin{pmatrix} 1 \u0026amp; -1-\\epsilon \\\\ -1 + \\epsilon \u0026amp; 1 \\end{pmatrix} Taking matrix norms,\n‚à•A‚à•‚àû=2+œµ\\lVert A \\rVert_{\\infty} = 2+\\epsilon and ‚à•A‚àí1‚à•‚àû=œµ‚àí2(2+œµ)\\lVert A^{-1} \\rVert_{\\infty} = \\epsilon^{-2}(2+\\epsilon)\nthen, Œ∫(A)=‚à•A‚à•‚àû‚à•A‚àí1‚à•‚àû=(2œµ+1)2\u0026gt;4œµ2\\kappa(A)=\\lVert A \\rVert_{\\infty}\\lVert A^{-1} \\rVert_{\\infty}= (\\frac{2}{\\epsilon} + 1)^{2} \u0026gt; \\frac{4}{\\epsilon^{2}} let œµ‚â§0.01‚üπŒ∫(A)=40,000\\epsilon \\le 0.01 \\implies \\kappa(A)=40,000\nAs œµ‚Üí0,A‚ÜíB\\epsilon \\rightarrow 0, A \\rightarrow B and Œ∫(A)‚Üí‚àû\\kappa(A) \\rightarrow \\infty. This will result in very sensitive computation since Œ∫(A)‚Üí‚àû\\kappa(A) \\rightarrow \\infty References [1] Matrix norms 30 - Imperial College London\n[2] Prof. S. Baskar, \u0026ldquo;Week 3 : Lecture 16 : Matrix Norms: Condition Number of a Matrix.\u0026rdquo;, YouTube, uploaded by IIT Bombay July 2018, 02 February 2023, https://www.youtube.com/watch?v=IXNz7BU0CDc\n[3] Robert van de Geijn, \u0026ldquo;1 4 1 The condition number of a matrix\u0026rdquo;, YouTube, uploaded by Advanced LAFF, 17 September 2019, https://www.youtube.com/watch?v=CGfXxLnnHtg\u0026amp;t=379s\n[4] Jones, A. (2020, May 17). Condition numbers. Andy Jones. Retrieved April 15, 2023, from https://andrewcharlesjones.github.io/journal/condition-number.html\n","permalink":"https://www.eulogs.com/posts/condition_number/","summary":"Condition Number A condition number measures how sensitive is the solution of equation(s) to perturbations in the input is.\nIntroduction Consider a system of linear equations in the form of \\(Ax=b\\), where we are interested to find \\(x\\). So we have a solution space of \\(x \\in R^{n}\\) for \\(b \\in R^{m}\\) while unchanging \\(A\\).\nNow our objective is to quantify the change in solution space of \\(x\\) if we add some perturbations or error term to input space of \\(b\\).","title":"Condition Number in Matrix"},{"content":" Life is not complex. We are complex. Life is simple, and the simple thing is the right thing.\n-Oscar Wilde\nOver the span of last decade, Deep Learning has made our life simpler by bringing its power into the applications of healthcare, self-driving cars, fraud-prevention and many more. Since the launch of ChatGPT many companies have made applications which help users in brainstorming and simplifying comlpex ideas, assist in writing content, even assist in writing codes etc. Their predictive analysis power depends on the assumption that these models are learning what we intend them to learn, e.g. to classify a cow, model must be looking at cow and not at grass. But has it been the case the whole time?\nIntroduction Lets\u0026rsquo; start with an example of Bob and Alice who are studying for high school exams. Bob used a strategy of mugging up while Alice likes to understand things in detail and then ponder over it. Bobs\u0026rsquo; strategy got him good grades in test unlike Alice, but can Bob extrapolate/generalize this strategy in order to apply the learned concepts to real world applications like Alice. Alice can use her strategy almost anywhere in life and would benefit from it but Bob will fail in the wild. Bob has taken shortcut to complete the task instead of actually learning principles. But are these shortcuts bad? When human driver takes shortcut route to reach destination its good for you since it saved time. So it depends on the type of task we are doing and also the context of it to determine taking shortcut is okay or not.\nWe are using Deep Learning techniques especially for the field of computer vision in self drving cars, security cameras, activity recognition etc on daily basis. But even after 5 decades we haven\u0026rsquo;t really understood the underlying principles behind the success of these models. Only on the basis of test performances we are deploying them in the wild. Since they are being used as applications in court, defence, person identification etc which makes the need to understand them necessity than leaving it as another field of scientific endeavour[1].\nTask Image Captioning Recognize Pneumonia Answer Question Problem Describe scene as grazing sheep Fails on scans from new hospital Changes answer if irrelevant information is added Shortcut Uses background(hillside) to recognize primary object Looks at hospital token, not lungs Only looks at last sentence and ignores context In the above table Deep Neural Nets are often solving problems taking shortcuts instead of learning the core features. This is prevalent but not only limited to the field of deep learning, infact humans and animals also tend to take shortcuts as we saw an example in the starting of Introduction. These shortcuts tend to work well for confined space but do not generalize well in the real world. For e.g. Amazons\u0026rsquo; DNN model made hiring decision on basis of resume, but were biased for men.\nThis has given rise to the new field of study in Deep Learning called Shortcut Learning. Shortcuts can be understood as spurious features that perform well on standard benchmarks but fail to generalize to real-world settings[2]. Spurious features are features that were used during training(e.g. grass) of predictive model e.g classification model but are not useful in general real-world settings(e.g. grass does not imply prediction of cow).\nRelated Works The field of shortcut learning is not novel problem, it been there for long time in the field of machine learning with different names\nLearning under Covariate Shift Anti-Casual Learning Dataset Bias Clever Hans Effect Shortcut learning works like an umbrella term to consolidate all the above terms and likewise under the hood to work on the problem as a whole.\nLets\u0026rsquo; start understanding shortcut learning from the biological perspective first.\nShortcut Learning in Biological Neural Networks Unintended Cue Learning \u0026ldquo;In experimental psychology, unexpected failures are often the consequence of unintended cue learning. For example, rats trained to perform a colour discrimination experiment may appear to have learned the task but fail unexpectedly once the odour of the colour paint is controlled for, revealing that they exploited an unintended cue\u0026mdash;smell\u0026mdash;to solve what was intended to be a vision experiment\u0026hellip;1\u0026rdquo;\nResearchers intended the problem to be of vision but rats found the solution by learning the smell of the colors which was unintended by researchers. Though solution worked for given experiment but it will be hard to extrapolate the learnings to other experiments.\nSurface Learning Students\u0026rsquo; learning process has been broadly classified into two groups 1. Deep Learning and 2. Surface Learning. Taking the reference of Bob and Alice example, Alice would be deep learner and Bob would be the Surface Learner. Bob was focused on grasping the main points and memorizing them, on the other hand Alice showed interest in the meaning of the topics to deepen the understanding by cross linking the learnings with other knowledge. This aid deep learners to transfer their learning strategy to other topics of study or not just subject matter but also to real life dealings. Analogy to machine learning can be, Transfer Learning. Bobs\u0026rsquo; transfer learning is highly intended to fail on other topics unlike Alices'.\nExample showing the decision rules of Shortcut Learning Any machine learning or deep learning model apply decision rules in order to categorize or predict or do any such tasks on a dataset. This defines a relationship between input and output of the model. In this section we will take the example from [1]\nIn the above figure, we are given a dataset containing two categories(star ‚≠ê , crescent üåô) with labels A, B respectively. In the machine learning we usually divide the dataset into training set and test set in some proportion say 80:20 or if the number of datapoints are large then 90:10. Also our datasets usually follow some distribution class wise e.g images of cow would be mainly found in grassfields. Now after dividing the dataset into train and test sets we get i.i.d which is identically independent distribution, think of it as a subset sampled from the dataset. Such that this subset follows the same distribution as dataset. But when only some part of dataset is taken in consideration to make a subset e.g. cow is taken as object of interest, but we change the conditions in which those objects are existing e.g. cow on road instead on grassland. Then this is o.o.d which is out of distribution.\nAfter the model has been trained on the train set, its been tested on i.i.d subset where location of classes seemed to have not changed. Because of which Neural Network model were able to classify them correcty. But, why location? why not shape?. For that we used o.o.d subset in which we changed the location of classes and neural network model failed to classify it correctly. If it would be learning the classification on the basis of shapes which is intended feature then it would have answerd correctly. Wrong classification shows that it learned the location of classes in order to classify which is spurious feature.\nWhere do these shortcuts come from? Principle of Least Effort Phenomenon of \u0026ldquo;Principle of Least Effort\u0026rdquo; came from the field of lingustics where speakers tend to minimize the amount of effort involved in communication. E.g. speaking \u0026ldquo;plane\u0026rdquo; instead of \u0026ldquo;airplane\u0026rdquo;, merging \u0026ldquo;p\u0026rdquo; and \u0026ldquo;b\u0026rdquo; in \u0026ldquo;cupboard\u0026rdquo;. Related analysis can be found in Morgans\u0026rsquo; Canon, Monitoring Early Training Dynamics.\nSkewed Training Dataset Today we mostly use crowd-sourcing platforms like Amazon Mechanical Turk for labeling in vision data, annotating in language data etc for its low cost and scalability. But this comes with its\u0026rsquo; own price of biases and artifacts due to collection bias. Since labelling and annotating datapoints are not done by single entity, this entails individual biases from annotators. For e.g. in NLI task, annotators have usually written contradiction by using not and this created a spurious feature for language model to base its predictions on. Now these annotations are not wrong, but we need robust models to handle this type of bias.\nNeural Network Models In LLMs its been seen that two factors are important in order to determine the models\u0026rsquo; robustness. (1) Model Size (2) Pre-training objective\nModel Size Model size is measured by number of parameters while keeping the kind of architecture and pre-training objective same. Now generalization ability is measured by the performance of model on o.o.d dataset. Its been shown that generalization ability of larger models are better than those of smaller ones, also smaller models are prone to capture spurious features and more dependent on data artifacts for prediction [5]. For e.g. BERT-large will generalize better than BERT-base. Following this we can also talk about model compression, a theoritical perspective has shed some light by showing that there is a tradeoff between size of model and robustness[7]. Empirically its also been found that compressing the LLM reduces the robustness and especially the models that have been compressed using knowledge distillation are more vulnerable to adversarial attacks.\nPre-training Objectives Lets\u0026rsquo; take 3 kinds of LLMs: BERT, ELECTRA, and RoBERTa,. Now for Adversarial NLI dataset, ELECTRA and RoBERTa have better performance than BERT. Similarly, its\u0026rsquo; been shown that RoBERTa-base outperformed BERT-base on HANS test by 20%. Also empirical evidence show that above three models have different levels of robustness most probably because of inductive bias as pre-training objective.\nDataset Bias Lets\u0026rsquo; take an example of penguin. What makes penguin a penguin? Penguin itself or the context, ofcourse penguin itself but context helps for increasing the probability of correctness. But if only context becomes more important than object itself, that\u0026rsquo;s a problem. If we have penguin in snow data mostly, then strategy of classifying snow as penguin becomes successful even when penguin would not be there. Indeed many models base their predictions on context than object itself and this creates shortcut opportunity for models.\nTo deal with these dataset biases researchers proposed to scale up the dataset size in order to have sufficient samples with more diversification. Consequently even large real world datasets like Imagenet are highly influenced by it [4]\nDiscriminative Learning Generally it is sufficient for discriminative model to rely on textures and local structures for object classification. But in generative modelling model needs to understand the global shape of object also and not just textures for generating human understandable images. Model is better off learning the textures and ignoring the shape bias for learning object classification task and that becomes a problem e.g. dog image may have the texture of elephant but humans would be classfying the image on the basis of shape rather than texture.\nStandard DNNs are intended to learn some workable relationship between input and output and not explicitly take the human interpretability factor of the following relationship into consideration. This ease of finding relationship severly bias the model to learn overly simplistic solutions which perform well on standard benchmarks but fail in real world[1].\nShortcut Learning across Deep Learning Computer Vision Slight changes in the translation, rotation, adding noise, changing background of the object in the image has shown to derail the predictions of DNNs. Models learn shortcuts that are inherent to the distribution of the dataset because of which these models do not perform well when used as transfer learning. Since they have learned the representations which will only work in limited capability under distribution shift. Tiny invisible changes to human eye in the images can alter the predictions of neural network by great margin. This is an example of Adversarial Learning which is one of the most severe failure cases of neural networks[1]\nNatural Language Processing Studies have found that Large Language Models (LLMs) are vulnerable to adversarial attacks and have low generalization power[5]. Empirical Analysis shows that BERT-like models base their performance of Natural Language Inference (NLI) task on some spurious features like unigrams not, do, is and bigrams will not. Some models were relying on lexical matching of words between question and original passage in reading comprehension task, which tend to ignore the understanding of comprehension. Natural Language Understanding (NLU) dataset contains artifacts and biases, due to which LLMs using training strategy of Empirical Risk Minimization (ERM) have learned to rely on spurious correlations of them and class labels.\nNow features learned by the model can be broadly classified into three categories: (1) Useless Features (2) Non-robust Features (3) Robust Features. Shortcut Learning can also be understood as a phenomenon that rely highly on non-robust features. These type of features are aligned with biases in training data. Below figure may help in providing better understanding at it.\nLexical Bias: Some lexical features like stop words, numbers, negation words have high correlation of co-occurence with certain class labels. E.g. LLMs tend to give contradiction predictions whenever there exist negation words e.g. never, no in input\nOverlap Bias: Reading comprehension models use the overlap/lexical matching between passage and question pair for prediction rather than understanding underlying task. Similarly, Question Answering (QA) models perform by relying on heuristics of question and context(knowledge base) lexical matching.\nPosition Bias: Lets understand this using an example, take the QA task where answers to most of the questions lie in the kth line in each passage. This will make QA model to use position cues as spurious feature for prediction.\nStyle Bias: LLMs have leared to rely on spurious text styles as shortcuts. These features can be further utilized as backdoor attacks for adversarial pertubations to decrease models\u0026rsquo; robustness.\nFairness and Algorithmic Decision-Making Amazon trained a deep neural network to filter out strong candidates for a job on the basis of resumes, but later it was found out to be gender biased towards men. Gender was such a strong predictor that even after removal of that attribute from dataset, model always found a way around, e.g. inferring gender from all-woman college names. When human biases are not only replicated, but worsened by a machine, this is referred to as bias amplification[1]. Amplification of disparity among groups over time is referred to as disparity amplification. Example regarding latter can be a shortcut feature that focus on majority group in dataset than underrepresnted.\nIdentification of Shortcut Learning Comprehensive Performance Testing We need to test models on o.o.d datasets to understand if the model has learned the features that we are interested in. HANS (Heuristic Analysis) evaluation set is proposed to evaluate whether NLI models have syntatic heuristics: the lexical overlap heuristic, the subsequence heuristic, the constituent heuristic. Following the philosophy of HANS, a new task has been created: FEVER for facts verification[5]. These o.o.d tests have shown performance degradation for State-of-the-art Large Language Models.\nAdversarial Attacks makes an interesting diagnostic tool. If a successful and innocuous adversarial attack can change the predictions of model without changing semantic content, then this is indicative of presence of a shortcut.\nAblation studies are useful in order to understand what essential factors are contributing to models performance. Recent ablation studies show that word order does not matter for pre-trained language models. This points out to the fact that LLMs success relies on the ability to understand the correlation between the word co-occurences no matter where words lie in a sentence.\nExplainability Analysis Deep Neural Networks are black boxes which employs a limitation to understand the decision process. Explainability methods are helpful in those scenarios in order to provide some useful insights into the working of DNNs.\nFeature Attribution Assume you have an input \\( x \\) for NLP task, then \\( x_{i}\\) implies each token. Feature Attribution algorithm \\(\\Phi\\) will calculate \\(\\Phi_{i}\\) which denotes the contribution score of \\(x_{i}\\) for model prediction.\nThe tokens in the training set can be modeled using long-tail distribution. This can create a shortcut for LLM to concentrate biasedly towards the head of the distribution even though tail of the distribution has abundant information.\nInstance Attribution You are what you eat\n\u0026ndash;Victor H. Lindlahr\nThe following quote also applies to Deep Neural Networks except they consume data and then base their prediction. Every preceding datapoint affect the prediction of sucessive sample in dataset. Instance Attribution methods are useful in predicting the data samples that contributed more to the models\u0026rsquo; prediction performance for particular instance/datapoint. Empirical analysis indicates that the most influential training data share similar artifacts e.g. high overlapping bias between premise and hypothesis for NLI task.\nMorgans\u0026rsquo; Canon for Machine Learning üìñ Anthromorphism The tendency of humans to attribute human-like psychological characterstics to non-humans on the basis of insufficient empirical evidence Psychologist Lloyd Morgon developed a guideline for interpreting non-human behaviour in response to the fallacy of Anthromorphism.\nMorgons\u0026rsquo; Canon says that \u0026ldquo;In no case is an animal activity to be interpreted in terms of higher psychological processes if it can be fairly interpreted in terms of processes which stand lower on the scale of psychological evolution and development\u0026rdquo;\nSimple correlation would be considered low on psychological scale than scene understanding. Morgons\u0026rsquo; canon in terms of machine learning can then be \u0026ldquo;Never attribute to high-level abilities that which can be adequately explained by shortcut learning\u0026rdquo;\nMorgons\u0026rsquo; canon can also be understood as Occams\u0026rsquo; Razor that says \u0026ldquo;It is futile to do with more what can be done with fewer\u0026rdquo;. A small patch added to image at certain location for all the images of the class is enough for the model to base its predictions and, complex objects and textures of say some animal would not even be needed for it to classify.\nMonitoring Early Training dynamics Up until now, community has viewed shortcut learning as a distribution shift problem, but [2] formalized the guideline of Morgons\u0026rsquo; Canon to show difficulty of spurious feature is equally important in order to understand or identify shortcuts. They argued that it can be captured by monitoring early training dynamics, think of monitoring training dynamics as observing the changes of neural network predictions, maybe weights or any likewise insight during the course of training.\nPremises that support the hypothesis: \u0026ldquo;Difficulty of spurious features is important for shortcut learning\u0026rdquo;\nShortcuts are only those spurious features that are easier to learn than the intended features. Initial layers of DNN learn easy features or low level features, whereas later layers tend to learn harder ones or high level features. Easy features are learned much earlier than the harder ones during training [6] lets solve the premises using propositional logic, for ease we will use \\(premise_{n} \\rightarrow p_{n}\\)\n\\(p_{1}: S\\) \\(p_{2}: I \\land L\\) \\(p_{3}: E \\land H\\) \\(S:\\) \u0026ldquo;Shortcuts are easy features\u0026rdquo; \\(I: \\) \u0026ldquo;Initial layers learn easy features\u0026rdquo; \\(E: \\) \u0026ldquo;Easy features are learned earlier during training\u0026rdquo; \\(L: \\) \u0026ldquo;Later layers learn hard features\u0026rdquo; \\(H: \\) \u0026ldquo;Hard features are learned later during training\u0026rdquo; conjuction of \\(p_{2}, p_{3}\\) \\(= p_{2} \\land p_{3} = I \\land L \\land E \\land H = (I \\land E) \\land (L \\land H)\\) we are only concerned with easy features (\\(I\\)) rather than hard features, since spurious features are easier to learn. So \\(L \\land H\\) can be removed from above equation.\nthen, \\(p_{1} \\land p_{2} \\land p_{3} = S \\land I \\land E\\) This leads to conjecture, \u0026ldquo;Shortcuts are easy features that are learned by initial layers early during training\u0026rdquo;\nNow we need to define the notion of task difficulty(\\(\\Psi\\)) which actually depends on model and data distribution (\\(X, y\\)) where \\(X\\) is input and \\(y\\) is label. Then \\(\\Psi_{M}^{P}(X \\rightarrow y)\\) indicates difficulty of predicting label \\(y\\) given input \\(X\\) for model \\(M\\) and some distribution \\(P\\), where \\(X, y \\sim P\\). Spurious feature \\(s\\) is potential shortcut for model \\(M\\) iff \\(\\Psi_{M}^{P_{tr}}(X \\rightarrow y) \u0026gt; \\Psi_{M}^{P_{tr}}(X \\rightarrow s)\\). Which means, difficulty of predicting spurious feature \\(s\\) is easier than predicting label \\(y\\) for model \\(M\\) for a training distribution \\(P_{tr}\\).\n‚ùóWhat does it mean to predict spurious features? Labels are the true predictions for an input, and model can learn to output these labels either by learning intended features or spurious features. So predicting spurious features means correctly predicting the input using spurious features. But how would we measure the task difficulty? using two metrics Prediction Depth and \\(\\nu\\)-Usable Information. Prediction Depth of an input is defined as minimum number of layers required by the model to classify the input. \\(\\mathit{\\boldsymbol{\\nu}}\\)-Usable Information is defined as amount of usable information in some input \\(X\\) that can be used by model to predict \\(y\\), higher the usable information easier the dataset or datapoint/sample is.\nWe are close to the end of this section, hold tight. Now consider two datasets \\(D_{s} \\sim P_{tr}(X, y)\\) with spurious features and \\(D_{i} \\sim P_{te}(X, y)\\) without spurious features. Taking some assumptions in Prediction Depth (PD) if mean PD of \\(D_{s}\\) is less than mean PD of \\(D_{i}\\) then \\(\\nu\\)-Usable Information for \\(D_{s}\\) is higher than for \\(D_{i}\\). In such scenerio model will tend to learn spurious features than intended ones. And this can help to identify spurious features.\nDatasets lying on the mean PD axis in order of difficulty. KMNIST with shortcut has least difficulty due to the introduction of shortcut whereas KMNIST with no shorcut is even difficult than FMNIST\nMitigation of Shortcut Learning Dataset Refinement The aim of dataset refinement is alleviating biases from training datasets. There are some ways using which we can alleviate biases.\nBy providing additional instructions to crowd workers to drop down the use of words that are highly indicative of annotation artifacts.\nUsing Adversarial Filtering to filter out the bias in dataset. Models trained on these debiased datasets have to learn more generalizable features and rely on common sense reasoning.\nUsing data augmentation methods like counterfactuals, MixUp, CutPaste, rotation and many more can be helpful in debiasing.\nAdversarial Training This is implemented in two ways:\nTask classifier and adversarial classifier jointly share the same encoder and the goal of the adversarial classifier is to provide correct predictions for the artifacts in training data.\nModel is trained to minimize the loss function over generated adverarial examples but such techniques haven\u0026rsquo;t shown much generalization abilities.\nMany techniques like \\(l_{1}\\), \\(l_{2}\\) regularization, CutOut, MixUp and early stopping have been investigated, where early stopping is found to be most effective.\nProduct-of-Expert(POE) This provides us with an opportunity to model high dimensional data by combining some low dimensional models, where every low dimensional model will focus on some particular constraint of the problem by giving high probability. Since our goal is to debias the model, we can follow two stage system to achieve this.\nIn first stage, bias-only model is trained to capture bias of the dataset. In second stage, debiased model will be trained using cross-entropy loss and only the weights of debiased model will be updated. In this way debiased model will use the information from biased model to improve its predictions.\nTraining Samples Reweighting This is also known as worst group loss minimization. The main idea of the following technique is to assign higher weight to hard training examples in a batch. This is because model tend to learn easy features more than hard ones and so improving the performance of worst group (hard samples) is beneficial for model robustness. [8] used a combination of Low Capacity Network (LCN), and High Capacity Network (HCN) for reweighting the data samples.\nWe know easy features are learned in early layers of neural network according to Prediction Depth Analysis we did above. LCN can then very well capture those features by been trained to fit to the dataset such that it will give high probabilities for spurious or here easy featues. These probabilities can then be used to reweight the samples that are hard such that model will focus more on hard samples to find relevant and hopefully intended features to learn underlying distribution of the dataset. Imbalance Dataset problem can also be part of this section which researchers of Meta tried to solve by introducing focal loss.\nContrastive Self-Supervised Learning Contrastive Learning comes as a subset to Representation Learning which aims to learn better representations by creating auxillary tasks that eventually help the model to perform better on main task or say downstream tasks like classification. Constrastive Learning methods usually suffers with feature suppression, say you have two images of one is dog running on a sunny day and another is cat standing still under shade. Model will discriminate both on the basis of sunny and shady supressing other intended features. So auxillary tasks need to created very carefully keeping problems of feature suppression in account.\nIntroducing Challenging Evaluation Datasets Adversarial GLUE is proposed for adversarial robustness evaluation which contains 14 adversarial attack methods. Similary Checklist, Robustness Gym can be used to evaluate the robustness of LLMs. Introduction to datasets that contain wide range of tasks, biases and so on can give better insights about Deep Neural Nets performance. [4] introduced Spurious ImageNet which consists of 40 spurious features and each consists 75 images, images didn\u0026rsquo;t had any class objects like car, animal, object but just spurious features. This allowed to check the influence of unintended features over the performance for any vision model.\nConclusion Every shortcut has a price usually greater than the reward\n\u0026ndash;Bryant H. McGill\nApplications powered using Deep Learning are taking world by storm but under the light of aid that these models are providing us, we shall not unlook the fundamental working principle of these models. Shortcut Learning rather being taken as another problem in the field of Neural Nets, it should be considered default for performance comparision and to better understand what our neural net is actually learning. Overcoming shortcut learning will help in solving fairness, robustness, deployability and trust worthiness of these models. This will eventually make machine decisions more transparent.\nCitation Cited as:\nP. Garg, ‚ÄúShortcut Learning: Belief trap of Deep Neural Networks,‚Äù Eulogs, Mar. 31, 2023. https://www.eulogs.com/posts/shortcut-learning/ (accessed Apr. 13, 2023).\nor\n1 2 3 4 5 6 7 8 @article{garg_2023, title = \u0026#34;Shortcut Learning: Belief trap of Deep Neural Networks\u0026#34;, author = \u0026#34;Garg, Priyam\u0026#34;, journal = \u0026#34;www.eulogs.com\u0026#34;, year = \u0026#34;2023\u0026#34;, month = \u0026#34;Mar\u0026#34;, url = \u0026#34;https://www.eulogs.com/posts/shortcut-learning/\u0026#34; } References Geirhos, Robert, et al. \"Shortcut learning in deep neural networks.\" Nature Machine Intelligence 2.11 (2020): 665-673 Murali, Nihal, et al. Shortcut Learning Through the Lens of Early Training Dynamics. 1, arXiv, 2023, doi:10.48550/ARXIV.2302.09344 Geirhos, Robert, et al. ‚ÄúUnintended Cue Learning: Lessons for Deep Learning from Experimental Psychology.‚Äù Journal of Vision, vol. 20, no. 11, Association for Research in Vision and Ophthalmology (ARVO), 20 Oct. 2020, p. 652. Crossref, doi:10.1167/jov.20.11.652. Neuhaus, Yannic, et al. Spurious Features Everywhere -- Large-Scale Detection of Harmful Spurious Features in ImageNet. 1, arXiv, 2022, doi:10.48550/ARXIV.2212.04871. Du, Mengnan, et al. Shortcut Learning of Large Language Models in Natural Language Understanding: A Survey. 1, arXiv, 2022, doi:10.48550/ARXIV.2208.11857. Karttikeya Mangalam and Vinay Uday Prabhu. Do deep neural networks learn shallow learnable examples first? 2019. Bubeck, S√©bastien, and Mark Sellke. A Universal Law of Robustness via Isoperimetry. 4, arXiv, 2021, doi:10.48550/ARXIV.2105.12806. Dagaev, Nikolay, et al. ‚ÄúA Too-Good-to-Be-True Prior to Reduce Shortcut Reliance.‚Äù Pattern Recognition Letters, vol. 166, Elsevier BV, Feb. 2023, pp. 164‚Äì171. Crossref, doi:10.1016/j.patrec.2022.12.010. https://doi.org/10.1167/jov.20.11.652\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","permalink":"https://www.eulogs.com/posts/shortcut-learning/","summary":"Life is not complex. We are complex. Life is simple, and the simple thing is the right thing.\n-Oscar Wilde\nOver the span of last decade, Deep Learning has made our life simpler by bringing its power into the applications of healthcare, self-driving cars, fraud-prevention and many more. Since the launch of ChatGPT many companies have made applications which help users in brainstorming and simplifying comlpex ideas, assist in writing content, even assist in writing codes etc.","title":"Shortcut Learning: Belief trap of Deep Neural Networks"},{"content":" DOI: Paper Link\nIntroduction Three levels of Intelligence\nMechanical Corresponds to repetitive tasks that require consistency and accuracy, e.g. order-taking machines in restaurants or robots in manufacturing assembly processes.\nAnalytical Corresponds to less routine task, but the one which is more inclined towards classification side (e.g., credit application determinations, market segmentation, revenue predictions, etc.)\nEmpathy, Intution and Creativity Few AI applications exist at this level. Although empathy and intution are believed to be directly related to human consciousness.\nProgression of AI into higher intelligence task can fundamentally disrupt the service industry and severely affect employment and business models as AI agents will replace more humans.\nGoals of Paper Focus on what is required for such conscious state to arise and how we can recognize conscious machines.\nPutting forward a theory on how consciousness would emerge in its primitive state in AI agents\nwith that, it will also put forward how conscious AI may progress towards a point that we can deterministically recognize it as conscious AI. Advancing our understanding of Empathic AI as final stage of intelligence.\nPreliminary Observation Turing (1950) introduced a test that later became known as the Turing Test to pinpoint when it can be said a machine (a standard computational machine) is capable of thinking.\nThe Turing Test can identify thinking machines only at their maturity when they have achieved linguistic indistinguishability from humans\nResearch on consciousness is vast and involves many scientific disciplines (e.g. sociology, neurology, psychology, pathology, philosophy, physics etc)\nProposition Principled framework that can identify thinking machines through their path toward maturity along with minimum requirements under which machine consciousness can emerge.\nConsciousness in AI is emergent phenomenon that manifests when two machines co-create their own language through which they can communicate their internal state.\nIntelligent Machines Weak AI Strong AI Information-processing machines that appear to possess full range of human cognitive abilities Defined as intelligent machines that possess all mental and comparable physical capabilities of humans, including consciousness using advanced computation Authors argue that a form of Strong AI with an emergent consciousness is possible\nConsciousness Theories Theories focusing on mind, and it\u0026rsquo;s states\nPhilo-Psychological theories of Consciousness Primarily concerned about what consciousness is and how it comes to be within a conscious entity (human).\nEntities that play significant role in philo-psychological theories\nstructure of mind\nmental states\nway information is processed, retrieved and stored.\nMain focus on internal processes while acknowledging the entity\u0026rsquo;s environment as a source of stimuli.\nRepresentationalism \u0026nbsp;\nR e p r e s e n t a r [ t e F i d i o u r n c s a e t l i O s r m d e M r e ] n t [ a H l i g R h e e p r r e O s r e d n e t r a ] t i o n [ P [ h I e n n t o e m n e t n i a o l n ] a l ] \u0026nbsp;\nPhilosophical idea of representationalism reduces consciousness to mental representations of objects in environment such as photos, signs, natural objects and their qualities.\nIntentional Phenomenal Mental State when it is about, or directed at some object Feeling of what it\u0026rsquo;s like to be you e.g. Belief that Earth is round, thought about laptop, perception of animal e.g. Perceptual experiences, pains, emotional feelings, episodes of mental imagery, deja vu NOTE: Most conscious experiences contain both Mental Representations\nFirst-Order Representationalism Core idea is that any conscious state is a representation and what it\u0026rsquo;s like to be in a conscious state is entirely determined by the content of that representation\nA representation is about something, and the content of that representation is what the representation is about\nE.g. word DOLPHINS (representation) is about dolphins (content)\n\u0026nbsp;\nThree Classifications are in Order\nThough a representation has content, a representation is not identical to its content\nThe representation DOLPHINS is an English word with eight letters, but its content dolphins does not have any letters. Conversely, dolphins swim, but the word DOLPHINS does not swim.\nThe content of a representation can be false, and can concern a non-existent thing\nThe story of Snow White is about someone who does not exist, but younger children sometimes find it hard to distinguish between the reality and fantasy\nAccording to representationalists, this explains why illusions, dreams, and hallucinations are possible\nConsciousness can misrepresent the world\nFirst-Order Representationalism does not hold that every contentful representation is conscious\nConscious Representation must be poised to interact directly with one‚Äôs beliefs and desires\nHigher-Order Representationalism Address the shortcomings of first-order representationalism by differentiating betweeen conscious and unconscious mental states.\nIt says, mental state is only considered conscious when another mental state within same conscious entity is aware of it.\nFor example, entity\u0026rsquo;s desire to express opinion becomes conscious only when entity is aware of such a desire.\nTongue in person\u0026rsquo;s mouth is aware of it and shows desires and sends signals to brain if it needs to taste something sweet or so.\nObservations These theories do not offer external observers a direct way of knowing whether they are dealing with conscious entity.\nBased on these theories, conscious entity may itself know that it is consciouss, but external observer (e.g. human) would not be able to know until that conscious entity inform itself.\nTheory is needed that can potentially offer external observers a way to examine and understand whether an entity (e.g. AI agent) can be considered conscious\nSocial-Self Theory of Consciousness Social-Self theory of consciousness does not interpret consciousness as an individual phenomenon rather a social phenomenon.\nFollowing theory focus on individual acts within a social context\nEnvironment must exist within which actors communicate with each other.\nNagels\u0026rsquo; Conceptualization of Consciousness Organism is conscious when it knows what it is like to be another organism\nThus, other conscious organisms must exist within the conscious entity\u0026rsquo;s immediate environment to make it possible for conscious organism to experience what it like to be the other.\nSymbols EXAMPLE: One can assume that a person intends harm if that person approaches with clenched fist. Victim will defend itself from imminent attack while initiator will respond to defenders\u0026rsquo; action. This back-and-forth exchange of symbols constitutes a matrix of social acts or a social matrix\nClenched fist would be considered symbol that carries same meaning for all involved actors.\nConsciousness in social-self theory requires a social matrix consisting of social acts and the exchange of symbols that lead to creation of language.\nObservations Theory not concerned with mental processess, existence of mind, internal state which is assumed that all actors bear implictly.\nEntity might know it is conscious, but external observer might not until conscious entity informs the observer.\nNone of them (Philo-Psychological and Social-Self theory) alone can provide guidance in positively determining whether an entity is conscious.\nAuthors put forward the idea that co-creation of the language is one of the missing links to consciousness\nTheories of AI Consciousness Authors provide 6 propositions regarding AI Consciousness which might help us to formulate or discover a conscious AI agent.\nFor consciousness to emerge, two AI agents capable of communicating with each other in a shared environment must exist.\nMead(1934) stated that language in the form of vocal symbols provides the mechanism for the emergence of consciousness. He meant exchange of vocal symbols through social acts in a social matrix So a theory to percieve the emergence of consciousness would be the inception and development of a language among AI Agents. Language is a means of social interaction and a social phenomenon and so cannot be created in isolation but need atleast 2 AI Agents. We should also focus on the fact that communicating machines already exist, but they ain\u0026rsquo;t conscious. Such that communication becomes fundamental to our theory. For consciousness to emerge, AI agents must exchange novel signals\nTo infer emergence as a property of an existing system, one must observe something new, a fresh creation that emerges from system instead of being the result of the system\u0026rsquo;s working Creation: Spontaneous idea that appears without much deliberation instead of creativity inherent in deliberate problem-solving activities. These fresh creations should covey shared meanings among AI Agents. For consciousness to emerge, AI agents must turn novel signals into symbols.\nWe need more than a mere exchange of novel signals(fresh creations), but a shared meaning for independent onlookers to observe it. Symbols: Novel signals with shared meaning. These symbols are going to be building block of an AI-specific language. For instance, the object tree is arbor in Latin language and –¥–µ—Ä–µ–≤–æ in Russian. Any of the following words has no material advantage over one another. What\u0026rsquo;s important is AI agents have agreed to use word X for object tree Following is the first step of turning a signal to symbol by providing it with shared meaning. Meaning arises from agreement, and not from symbol itself. For such agreement to reach, AI Agent must have internal state. For consciousness to emerge, AI agents must have internal state\nTo infer a symbol of shared meaning among agents, sender should be aware and understand the meaning of that symbol as the reciever percieves it in a clear cut manner without vagueness or ambiguity. For a conscious entity to know what it is like to be the other, it must have an internal state in which it can reconstruct the meanings of other AI agent reponses. For consciousness to emerge, AI agents must communicate their internal state of time-varying symbol manipulation through a language that they have co-created.\nThree stages of development in the AI agents\u0026rsquo; path towards consciousness Creation of what in human language we say as noun\nTwo agents shoud agree on random signal to represent a static (time-invariant) the one not varying in time object in their environment Once such an agreement is reached, the signal is turned into a symbol and must be moved into AI agents\u0026rsquo; permanent memory to be used in future to refer to same static object e.g. signal X has become symbol for car. This process creates a symbol what we say in human language as noun Creation of what in human language we say as verb\ntwo agents should agree on a random signal or set of previously created symbols to represent a dynamic (time-variant) concept related to an object in their environment. e.g. decaying apple, snoring cat Those symbols should be able to describe the changing state of an object. This process creates a symbol what we say in human language as noun This process is similar to what in human language we say as verbs. Creation of new symbols by manipulation in real-time\nTwo Agents should use a set of previously created symbols or a mixture of old symbols and novel signals to express their time varying internal state of symbol manipulation In this final stage, agents will alo communicate their own internal states and how they manipulate symbols in real-time to create new symbols and their associated meanings. According to authors once the final/third stage is observed, we can conclude consciousness has emerged in Agents. For the emergence of consciousness to be concluded, an onlooker should be able to observe two agents reaching an agreement about atleast one of their state of time-varying symbol manipulaion\nIn order for onlookers to conclude that we are observing conscious AI agents, we need to detect communications about their internal state and how those state change over time. To detect agents\u0026rsquo; communication about their internal state, author propose that independent onlookers should recognize an explicit(clearly understood) agreement about the meaning of the communication e.g. Two agents cooperatively completing a task they are not programmed to do. Completing a task in such a manner can point to active agreements in the communication of intent and time-varying internal states between agents Service Implications With the Conscious AI in pursuit, we would need to necessitate new laws and bring forth concepts such as AI ethics and rights.\nEmpathic AI may affect the job market for humans, especially at the higher end of the job market in the service industry.\nEmpathic AI will also have the ability to change the human-AI relationship as people come to trust AI advice and actions, even in hedonic tasks, over advice and actions from another human.\nNOTE: The theory of mind also assumes empathy to be the most critical indicator of a fully developed human consciousness and also found to be positively and strongly correlated with trust in interpersonal relationships in which people tend to trust each other‚Äôs recommendations and advice\nConclusion Authors have introduced a theoritical framework to identify the requirements by which consciousness can emerge in AI agents along with another aim for AI research and practice contrary to current dominant paradigm of creating machines that are linguistically indistinguishable from humans. We need more research to develop refined techinical criteria to recognize the signs of emergent AI consciousness.\nExternal References Mehta N, Mashour GA. General and specific consciousness: a first-order representationalist approach. Front Psychol. 2013;4:407. Published 2013 Jul 16. doi:10.3389/fpsyg.2013.00407 ","permalink":"https://www.eulogs.com/posts/conscious-ai/","summary":"DOI: Paper Link\nIntroduction Three levels of Intelligence\nMechanical Corresponds to repetitive tasks that require consistency and accuracy, e.g. order-taking machines in restaurants or robots in manufacturing assembly processes.\nAnalytical Corresponds to less routine task, but the one which is more inclined towards classification side (e.g., credit application determinations, market segmentation, revenue predictions, etc.)\nEmpathy, Intution and Creativity Few AI applications exist at this level. Although empathy and intution are believed to be directly related to human consciousness.","title":"Conscious AI"}]